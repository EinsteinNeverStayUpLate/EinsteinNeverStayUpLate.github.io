{"meta":{"title":"Virux","subtitle":"","description":"","author":"Virux","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"function pointer","slug":"function_pointer","date":"2021-04-21T14:54:15.000Z","updated":"2021-04-21T15:04:24.166Z","comments":true,"path":"2021/04/21/function_pointer/","link":"","permalink":"http://yoursite.com/2021/04/21/function_pointer/","excerpt":"","text":"1. Declare function pointer12345678910format: return type (*funtionPointerName)(list of parameter types)example:int (*pfunction) (int,int);assign value:int sum(int a,int b)&#123; return a+b;&#125;pfunctioin=sum;call function through pointer:int result=pfunction(4,4); 2.Declare array of function pointer1int (*pfun[3])(int,int); 3. Function pointer as an argument of other functions1234int any_function(int(*pfun)(int a,int b),int x.int y);int sum(int ,int);//call any_functionany_function(sum,4,5);","categories":[{"name":"C","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[],"author":"Virux"},{"title":"access cycle and access time","slug":"access cycle and access time","date":"2021-04-21T14:17:21.000Z","updated":"2021-04-21T15:02:43.195Z","comments":true,"path":"2021/04/21/access cycle and access time/","link":"","permalink":"http://yoursite.com/2021/04/21/access%20cycle%20and%20access%20time/","excerpt":"","text":"存取时间：存取时间是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。 存取周期：存取周期又称为读写周期或访问周期。它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立访问存储器操作之间所需的最小时间间隔。 上面两个概念乍一看基本相同，其实不一样。关键在于存取周期=存取时间+恢复时间。 那么What is recover time？ 对任何一种存储器，在读写操作之后，总要有一段恢复内部状态的复原时间。对于破坏性读出的存储器，存取周期往往比存取大得多（这意味着恢复时间较长）。故通常来说存取周期是大于存取时间的。（图在王道P94）","categories":[{"name":"computer hardware","slug":"computer-hardware","permalink":"http://yoursite.com/categories/computer-hardware/"}],"tags":[],"author":"Virux"},{"title":"infix expression into prefix expression","slug":"infix expression into prefix expression","date":"2021-04-21T14:12:42.000Z","updated":"2021-04-21T15:04:46.367Z","comments":true,"path":"2021/04/21/infix expression into prefix expression/","link":"","permalink":"http://yoursite.com/2021/04/21/infix%20expression%20into%20prefix%20expression/","excerpt":"","text":"基本思想：从左到右扫描，遇到数字直接输出，遇到+，-，*，/则进栈。入栈规则如下： 遇到一个操作符则与栈顶元素比较优先级，若大于栈顶操作符的优先级则将该操作符入栈，否则不断将操作符出栈直至该操作符优先级小于栈顶操作符（注意，同等优先级，左边的操作符优先级高）。举例如下： 将如下中缀表达式转化成后缀表达式：2+9/3-5 输出：2 栈： 输出：2 栈：+ 输出：29 栈：+ 输出：29 栈：+/ 输出：293 栈：+/ 输出：293/+ 栈：- 输出：293/+5-","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[],"author":"Virux"},{"title":"computer organization noun excerpts","slug":"computer organization noun excerpts","date":"2021-04-21T12:19:00.000Z","updated":"2021-04-21T15:03:34.006Z","comments":true,"path":"2021/04/21/computer organization noun excerpts/","link":"","permalink":"http://yoursite.com/2021/04/21/computer%20organization%20noun%20excerpts/","excerpt":"","text":"服务器(server)：用于为多用户运行大型程序的计算机，通常由多个用户并行使用，并且一般通过网络访问。 云计算(Cloud Computing)：在网络上提供服务的大服务器集群，它依赖于称为仓储规模计算机(Warehouse Scale Computer ,WSC)的巨型数据中心。一些运营商根据应用需求出租不同的服务器。 软件即服务(Software as a Service,SaaS)：在网络上以服务的方式提供软件和数据。其运行方式通常不是在本地设备上运行所有的二进制代码，而是通过诸如运行在本地客户端的浏览器的小程序登录到远程服务器上执行。典型的例子是Web搜索和社交网络。 程序性能影响因素：程序所用算法的有效性，用来建立程序并将其翻译成机器指令的软件系统，计算机执行机器指令的有效性。 计算机系统结构中的8个伟大思想：面向摩尔定律的设计（Moore’ Law）；使用抽象简化设计；加速大概率事件（common case fast）；通过并行提高性能；通过流水线提高性能（pipelining）；通过预测提高性能（prediction）；存储器层次（hierarchy of memory）；通过冗余提高可靠性。 编译程序(Compiler)：将高级语言翻译为计算机所能识别的机器语言的程序。 指令(Instruction)：计算机硬件所能理解并服从的命令。 重点1：组成计算机的5个经典部件是输入，输出，存储器，数据通路(datapath)（在计算机也称为运算器）和控制器，其中最后两个部件通常合称为处理器。你总能够把任何计算机（无论是现在的还是过去的）中的任何部件归于这五种之一。 集成电路（Integrated Circuit）：也叫芯片（chip），一种将几十个至几百万格晶体管连接起来的设备。 指令集体系结构（instruction set architecture）：也叫体系结构，是低层次软件和硬件之间的抽象接口，包含了需要编写正确运行的机器语言程序所需要的全部信息，包括指令，寄存器，存储访问和I/O等。 应用二进制接口（Application Binary interface）：用户部分的指令加上应用程序员调用的操作系统接口，定义了二进制层次可移植的计算机的标准。 重点2：无论是硬件还是软件都可以使用抽象分成多个层次，每个较低的层次把细节对上层隐藏起来。抽象层次中的一个关键接口是指令集体系结构–硬件和底层软件之间的接口。这一抽象接口使得同一软件可以由成本不同，性能也不同的实现方法来完成。 易失性存储器(volatile memory)：类似于DRAM的存储器，仅在加电时保存数据。 非易失性存储器(nonvolatile memory)：在断电时仍可保持数据的存储器。如DVD。 晶体管（transistor）：是一种收电流控制的开关。 响应时间（response time）：也叫执行时间（execution time），是计算机完成某任务所需的总时间，包括硬盘访问，内存访问，I/O活动，操作系统开销和CPU执行时间等。 吞吐率（throughput）：也叫带宽（bandwidth），性能的另一种度量参数，表示单位时间内完成的任务数量。","categories":[{"name":"computer hardware","slug":"computer-hardware","permalink":"http://yoursite.com/categories/computer-hardware/"}],"tags":[],"author":"Virux"},{"title":"Hanming code","slug":"Hanming Code","date":"2021-04-21T11:52:45.000Z","updated":"2021-04-21T15:04:38.768Z","comments":true,"path":"2021/04/21/Hanming Code/","link":"","permalink":"http://yoursite.com/2021/04/21/Hanming%20Code/","excerpt":"","text":"简介：Richard Hanming与1950提出，它具有一位纠错能力。 编码纠错理论内容： 任何一种编码是否具有检测能力和纠错能力，都与编码的最小距离有关。所谓编码的最小距离，是指在一种编码系统中，任意两组合法代码之间的最少二进制位数的差异。由纠错理论的 ​ L-1=D+C 且D&gt;=C L表示最小距离，D（detection）检测错误的位数，C（correct）纠正错误的位数。故通过加入检测位，可以有效提高检错能力和纠错能力。 Hanming Code插入检测位过程： 假设欲传送的信息n位，则根据 2^k&gt;=n+k+1，可以得出所要加入检测位的位数k。k确定后，就要知道这k位的位置和信息（0或1）。k位检测为插入二进制串后，形成n+k为的一个二进制串，此时还没确定位置和信息，只知道有一个n+k位的二进制串。这里规定，这个二进制串从左到右进行位置编号，从1到n+k。注意，Hanming Code一种非划分的分组检测方式，这意味着k位检测位需要承担各自小组的检测任务，这里的意思就是将n+k位的二进制串分成k组，但是组与组之间有重叠的。接下来讨论k位检测码的插入位置。对于一个n+k位的二进制串，检测码在位置编号为2^(i-1)处，即1,2,4,8,16…都是检测位。（IT’s rule ，don’t ask why）那么每一位检测码引领的组是哪些编号上的bit呢？第2^(i-1)(i=1,2,3,4,…)位上的的检测位所引领的bit的位置编号具有以下特点：这个位置编号转化为二进制后，从右到左数，第 i 位是1。（位置和小组确定）接下来讨论，检测位上是0还是1。通常来说，我们假设对于每一个检测位和其所引领的小组会形成一个奇偶纠错系统。这意味着对于每一个小组，我们通过奇原则（1的个数为奇数）或偶原则（1的个数为偶数）去检测，能够发现这一个小组（包括检测位在内）是否在传送过程中发生了错误。（注意，一般而言我们认为一串二进制出错只出错一位，而不会出错两个位，这是一种概率超过百分之九十的事件）。回到开头，我们如何确定检测位是0还是1？这里我们假设利用偶原则进行检验，则检测位Ci（i=1,2,4,8,16…)为 ​ Ci=其所引领的小组内的所有bit（不包括Ci）进行连续异或所得到的的结果 下面用一个例题概述上面过程，并给出接受方进行纠错的过程。 假设发送方欲发送信息0101，则经过Hanming 编码后，发送出去的信息是什么？ 首先： C1 C2 0 C4 1 0 1 确认了位置。 C1=0⊕1⊕1=0 （第3,5,7位的bit） C2=0⊕0⊕1=1 （第3,6,7位的bit） C4=1⊕0⊕1=0（第5,6,7位的bit） 故最终传送出去的信息位：0100101 假设接受方接到传送过来信息位：0110101，且双方已按偶原则编码，试问欲传送的信息是什么？ 首先，这串信息不能直接拿来就用，要像纠错。纠错过程实际上是对传送后的Hanming code形成新的检测位Pi（i=1,2,4,8,16，…），本质是将每一小组拿出来单独进行奇偶校验。 P1=第一位⊕第三位⊕第五位⊕第七位=0⊕1⊕1⊕1=1 P2=第二位⊕第三位⊕第六位⊕第七位=1⊕1⊕0⊕1=1 P3=第四位⊕第五位⊕第六位⊕第七位=0⊕1⊕0⊕1=0 （这里注意，对于连续的⊕，如果其中有偶数个1，则所得结果必是0） 由上可知第一组，第二组出错了。则出错位那一位？注意：我们上面已经说了，一般一位出错的概率最大。那么又因为第一，第二组出错，由此可知第一，第二组所共有的那一位（编号为3）出错。为什么不是编号为7的bit？因为假设编号为7出错，第三组也应该出错。所以将接收到的信息纠正为：0100101.","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[],"author":"Virux"},{"title":"SRAM and DRAM basic unit circuity  working principle","slug":"explanation on SRAM and DRAM basic unit circuity  working principle","date":"2021-04-21T11:45:16.000Z","updated":"2021-04-21T15:07:21.310Z","comments":true,"path":"2021/04/21/explanation on SRAM and DRAM basic unit circuity  working principle/","link":"","permalink":"http://yoursite.com/2021/04/21/explanation%20on%20SRAM%20and%20DRAM%20basic%20unit%20circuity%20%20working%20principle/","excerpt":"","text":"工作原理如下： 读出时：行地址选择和列地址选择有效，T5，T6，T7，T8打开。假设A端为高电平，通过T6送进位线A，经过T8，送进读出放大器，输出。读入时，经过两个写放大器的相反信号分别经过T7，T8送进A’和A端，A‘和A端两端是相反的信号。 工作原理： 读出时，T4置一预充电信号，接着读选择项打开T2。若Gg有足够多的电荷（即Cg存储的是1），则T1导通且接地，此时读数据线降为低电平，读出“0”。反之，Cg没有足够多的电荷（存储的是0），T1截止，读数据线为高电平，读出“1”。 写入时，数据先到写数据线，再由写选择线打开T3，此时写数据线相当于电容Cg联通，写数据线上是“1”就写入“1”，是“0”就写入“0”。 工作原理： 读出时，字线上的高电平使T导通，如果Cg中有电荷（表示“1”），经T管在数据线上产生电流，读出为“1”。否则，数据线上不产生电流，视为读出“0”。这里注意，读操作结束时，Cg的电荷已释放完毕，故是破坏性读出，必须再生。 写入时，原理类似。","categories":[{"name":"computer hardware","slug":"computer-hardware","permalink":"http://yoursite.com/categories/computer-hardware/"}],"tags":[],"author":"Virux"},{"title":"I/O interrupt processing procedure","slug":"IO interrupt processing procedure","date":"2021-04-21T11:33:21.000Z","updated":"2021-04-21T15:07:38.828Z","comments":true,"path":"2021/04/21/IO interrupt processing procedure/","link":"","permalink":"http://yoursite.com/2021/04/21/IO%20interrupt%20processing%20procedure/","excerpt":"","text":"完整的操作过程如下： ​ 在执行主程序的过程中，会执行到一条输入指令。接着CPU将设备地址通过地址线送到接口电路中的设备选择电路，然后设备选择电路对该地址进行比较，看是否是该接口所连接的I/O设备，若是则该接口和相对应的设备就被选中，SEL 有效。只有SEL有效，接口电路才会开始工作。​ CPU将命令送到接口中进行译码。由图可以看出启动命令和SEL同时有效才会是触发器D和触发器B被设置。触发器B被设置为1，而触发器D被设置为0。 表示设备开始工作，但同时数据并没有准备好。NOTE：触发器B的另一个作用是，启动I/O设备开始工作。​ 然后I/O设备开始工作，将data送入DBR中，并将触发器B和触发器D进行修改，B改为0而D改为1。接着，如果MASK触发器的非端为1（表示该中断并未被屏蔽），此时INTR就会经过两个1被置为1。​ 接着CPU在一条指令的执行阶段结束后，发出中断查询信号。 然后将INTR送入排队器排队，经过排队器排队后，排队器的输出信号只有一个是1，其他都是0。 排队器的输出信号输出到设备编码器，然后CPU发出中断响应信号（INTA）。之后，设备编码器就会形成向量地址，该地址经过数据线传给CPU，传给PC。PC利用改地址去取出中断服务程序的路口地址（无条件跳转）。然后就进入中断服务程序。 中断服务程序的流程： 保护现场：保护程序的断点（中断隐指令完成）；保存通用寄存器和状态寄存器。 中断服务：与I/O设备直接相关，不同功能设备的中断服务程序不同。 恢复现场：从主存或堆栈中恢复CPU寄存器中的内容。 中断返回：中断返回指令。","categories":[{"name":"computer hardware","slug":"computer-hardware","permalink":"http://yoursite.com/categories/computer-hardware/"}],"tags":[],"author":"Virux"},{"title":"difference between computer architecture and computer organization","slug":"difference between computer architecture and computer organization","date":"2021-04-21T11:26:47.000Z","updated":"2021-04-21T15:04:02.025Z","comments":true,"path":"2021/04/21/difference between computer architecture and computer organization/","link":"","permalink":"http://yoursite.com/2021/04/21/difference%20between%20computer%20architecture%20and%20computer%20organization/","excerpt":"","text":"计算机体系结构(Computer Architecture)是指机器语言或汇编语言程序所看到的传统机器的属性，包括指令集，数据类型，存储器寻址技术等，大多属于抽象的属性 计算机组成（Computer Organization）是指如何实现计算机体系结构所体现的属性，它包含对许多程序员来说透明的硬件细节。例如，指令系统属于结构的问题，但指令的实现即如何取指令，分析指令，取操作数，如何运算等都属于组成的问题。因此，当两台机器指令系统相同时，只能认为他们具有相同的结构，至于这两台机器如何实现其指令，完全可以不同，即可以认为它们的组成方式是不同的。例如，一台机器是否具备乘法指令是一个结构的问题，但实现乘法指令采用什么方式则是一个组成的问题。 王道解释：计算机体系结构（Computer architecture)，是指机器语言或汇编语言程序员所看到的传统机器的属性，包括指令集，数据类型，存储器寻址技术等，大都属于抽象属性。 计算机组成（Computer Organization），是指如何实现计算机体系结构所体现的属性，它包含对许多程序员来说透明的硬件细节。例如，指令系统属于结构问题，但指令的实现即如何取指令，分析指令，取操作数，如何运算等都属于组成的问题。因此，当两台机器指令系统相同时，只能认为它们具有相同的结构，至于这两台机器如何实现其指令，完全可以不同，既可以认为它们的组成方式是不同的。例如，一个机器是否具备乘法指令是一个结构问题，但实现乘法指令采用什么方式（例如直接采用乘法器，亦或者采用加法器实现）则是一个组成的问题。 许多计算机厂商提供一系列结构相同的解散及，而它们的组成却又相当大的差别，即使是同一系列的不同型号机器，其性能和价格差异也很大。例如，IBM System/370结构就包含了多种价位和性能的机位。","categories":[{"name":"computer hardware","slug":"computer-hardware","permalink":"http://yoursite.com/categories/computer-hardware/"}],"tags":[],"author":"Virux"},{"title":"signal types in control bus","slug":"signal types in control bus","date":"2021-04-21T11:22:15.000Z","updated":"2021-04-21T15:05:50.077Z","comments":true,"path":"2021/04/21/signal types in control bus/","link":"","permalink":"http://yoursite.com/2021/04/21/signal%20types%20in%20control%20bus/","excerpt":"","text":"控制总线上常见的控制信号有： 总线请求 总线允许 中断请求 中断响应 存储器写 存储器读 I/O读 I/O写 时钟：用来同步各种操作 复位：初始化所有部件 传输响应：表示数据已被接受，或已将数据送至数据总线上。","categories":[{"name":"computer hardware","slug":"computer-hardware","permalink":"http://yoursite.com/categories/computer-hardware/"}],"tags":[],"author":"Virux"},{"title":"string matching KMP algorithm","slug":"string matching KMP algorithm","date":"2021-04-21T11:08:36.000Z","updated":"2021-04-21T15:05:47.100Z","comments":true,"path":"2021/04/21/string matching KMP algorithm/","link":"","permalink":"http://yoursite.com/2021/04/21/string%20matching%20KMP%20algorithm/","excerpt":"","text":"KMP算法利用子串的结构特点（前后缀有相同的部分）来减少子串与主串的比较次数。 前缀：必包含主串的第一个字符，且不包含主串的最后一个字符的主串的子串。后缀：必包含主串的最后一个字符，且不包含主串的第一个字符的主串的子串。例如： 主串：a 后缀=前缀=∅ 主串：abab 前缀={a,ab,aba} 后缀={b,ab,bab} 故前后缀公共部分为{ab} 算法的基本思想为：（设主串为s，子串为p）利用指向主串的指针i，和指向子串的指针j，当s[i] != p[j]时，子串指针退回到某个已知位置next[j]，而i指针不需要回退。next[j]的形成是利用子串本身的特殊结构，即p[1…j]具有相同的前后缀。该算法的难以理解的地方在于next数组的递归求出。 next数组的递归求解：（1）：求解next[j+1]时，设next[j]=k，若p[k]=p[j]，则next[j+1]=next[j]+1;（2）：若p[k] != p[j]。此时，尝试p[next[k]] 是否等于p[j]。这样做的原因在于，在每次求解next[j+1]时，都将该问题看作是一个新的模式匹配，而主串和子串都是原题中的子串。故，在比较p[k]=p[j] 失败时，继续往后推导，使得在第二个问题中，当主串（即子串）的p[j]与子串的p[k]不匹配时，通过继续往低位子串寻找，找到一个位置k’，同时有p[k’]=p[j]，这样就意味着，主串（即子串）j+1前面有k’个和子串的k’前的所有相匹配，故next[j+1]=k’+1。（3）： 若一直往后递归都没有找到某个位置的字符p[t]=p[j]，则next[j+1]=1。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"stringmatching.h\"int kmpMatching(char mstr[],int msize, char* sstr,int ssize) &#123; int* next = (int*)malloc(sizeof(int) * msize); constructNext(sstr, ssize, next); int mpointer = 1; int spointer = 1; /* char mstr[] = &#123; '0','a','b','a','a','b','c','a','b','a' &#125;; char sstr[] = &#123;'0','a','b','b'&#125;; */ for (; mpointer &lt;= msize; mpointer++) &#123; while (spointer != 0) &#123; while (mstr[mpointer++] == sstr[spointer++]&amp;&amp;spointer&lt;=ssize); if (spointer &gt; ssize&amp;&amp;mstr[mpointer-1]==sstr[spointer-1]) return mpointer - ssize; mpointer--; spointer = next[--spointer]; &#125; spointer = 1; &#125; return -1;&#125;void constructNext(const char* sstr,int ssize,int* next) &#123; next[1] = 0; next[2] = 1; for (int i = 3; i &lt;= ssize; i++) &#123; int k = next[i - 1]; while (sstr[i - 1] != sstr[k]) &#123; k = next[k]; if (k == 0)&#123; next[i] = 1; break; &#125; &#125; if (k!=0&amp;&amp;sstr[i - 1] == sstr[k]) next[i] = k + 1; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[],"author":"Viurx"},{"title":"structures for composition","slug":"structures for composition","date":"2021-04-21T11:03:47.000Z","updated":"2021-04-21T15:06:07.545Z","comments":true,"path":"2021/04/21/structures for composition/","link":"","permalink":"http://yoursite.com/2021/04/21/structures%20for%20composition/","excerpt":"","text":"It’s time you did something = you should have done it already or started it. We often use this structure to criticize or complain: It’s 10 o’clock and he’s still in bed. It’s time he got up. You’re very selfish. It’s high time you realized that you’re not the most important person in the world. If…should…: If Tom should phone while I’m out, tell him I’ll phone him back later. (If Tom should phone is similar to if Tom phones .With should, the speaker feels that the possibility is smaller ) I’ve left the washing outside. If it should rain, can you bring it in? You can also put should at the beginning of these sentences (Should something happen… ): Should Tom phone, can you tell him I’ll phone him back later? You can use any and no + comparatives (any longer/no bigger etc.): I’ve waited long enough. I’m not waiting any longer We expected their house to be very big but it’s no bigger than ours. Yesterday you said you felt ill. Do you feel any better today? This hotel is better than the other one and it’s no more expensive. may and might We use may or might to say that something is a possibility. Usually you can use may or might, so you can say: It may be true. or It might be true. She might know. or She may know. For the past we use may have (done) or might have (done): A: I wonder why Kay didn’t answer the phone. B: She may have been asleep. (= perhaps you left it in the shop). A: I can’t find my bag anywhere. B: You might have left it in the shop. (= perhaps you left it in the shop). A: I was surprised that Sarah wasn’t at the meeting. B: She might not have known about it. A: I wonder why Colin was in such a bad mood yesterday. B: He may not have been feeling well. should and should have (done) should: We use should when something is not right or what we expect. OR We use should to say that we expect something to happen: Those boys shouldn’t be playing football at this time. They should be at school. She’s been studying hard for the exam, so she should pass. should have (done): ‘You should have done something’ = you didn’t do it but it would have been the right thing to do: I’m feeling sick. I shouldn’t have eaten so much chocolate. I wonder why they ‘re so late. They should have been here an hour ago. Subjunctive Structures (虚拟语气结构) If sb did … , sb would do something. ** We are talking about the **present. If I found a wallet in the street, I would take it to the police. (NOTE: Here, I am not thinking about a real possibility; I’m imagining the situation and doesn’t expect to find a wallet in the street.) I’d be very frightened if somebody pointed a gun at me. if sb had done something, sb would have done something. It’s like the above structure, but we are talking about the past at this moment. If he had been looking where he was going , he wouldn’t have walked into the wall. The view was wonderful. If I had had a camera, I would have taken some photographs. about wish …. next time to note… would like to have done something (=I regret now that I didn’t or I couldn’t do something): It’s a pity we didn’t see Val when we were in London. I would like to have seen her again. We’d like to have gone on holiday but we didn’t have enough money. Also: You can use the same structure after would love/ would hate/ would prefer Although would love/hate/prefer are usually followed by to (infinitive), would mind is followed by -ing Something needs doing = something needs to be done The batteries in the radio need changing. (=they need to be changed) Do you think my jacket needs cleaning? (=…needs to be cleaned) It’s a difficult problem. It needs thinking about very carefully. We often use hardly +any/anybody/anyone/anything/anywhere: A: How much money have you got? B: Hardly any. I’ll have to go shopping. We’ve got hardly any food. The exam results were very bad. Hardly anybody in our class passed. in case AND in case of Ann might phone tonight. I don’t want to go out in case she phones.(because it’s possible she will phone) I’ll draw a map for you in case you can’t find our house.(=because it’s possible you won’t be able to find it) We use just in case for a smaller possibility I don’t think it will rain but I’ll take an umbrella just in case.(=just in case it rains) in case of is not the same as in case. In case of …=’if there is’ (especially in notices etc) In case of fire, please leave the building as quickly as possible. In case of emergency, telephone this number. Emphatic structure It is/was not until +emphasized part + that +other parts. He didn’t go to bed until his wife came back. It was not until his wife came back that he went to bed. As was discussed, it was not until the 19th century that the newspaper became dominant pre-electronic and in the company of periodical.","categories":[{"name":"grammar","slug":"grammar","permalink":"http://yoursite.com/categories/grammar/"}],"tags":[],"author":"Virux"},{"title":"popular BUS standards","slug":"popular BUS standards","date":"2021-04-21T09:11:26.000Z","updated":"2021-04-21T15:05:26.087Z","comments":true,"path":"2021/04/21/popular BUS standards/","link":"","permalink":"http://yoursite.com/2021/04/21/popular%20BUS%20standards/","excerpt":"","text":"ISA总线​ ISA（Industiral Standard Architecture)总线是IBM为了采用全16位的CPU而推出的，又称为AT总线，它使用独立于CPU的总线时钟，一年春CPU可以采用比总线频率更高的时钟，有利于CPU性能的提高。由于ISA总线没有支持总线仲裁的硬件逻辑，因此它不能支持多台主设备系统，而且ISA上的所有数据的传送必须通过CPU或DMA接口来管理，因此使CPU花费大量时间来控制与外部设备交换数据。ISA总线时钟频率为8MHz，最大传输率为16MBps，数据线为16位，地址线为24位。 EISA总线​ EISA（Extended Industrial Standard Architecture)是一种在ISA基础上扩充开放的总线标准，与ISA完全兼容，从CPU中分离出了总线控制权，是一种具有智能化的总线，能支持多个总线主控器和突发方式（成块传输）的传输。EISA总线的时钟频率为8MHz，最大传输率可达33MBps，数据总线为32位，地址总线为32位，扩充DMA访问范围达2^32 VESA总线​ VESA是由VESA（Video Electronic Standard Association，视频电子标准协会）提出的局部总线标准，又称为VL-BUS（Local BUS）总线。所谓的局部总线，是指在系统外为两个以上的模块提供高速传输信息通道。VL-BUS是由CPU总线演化而来的，采用CPU的时钟频率达33MHz，数据线为32位，可通过扩展槽扩展到64位，配有局部总线控制器，最大传输率达133MBps。通过局部总线控制器，将高速I/O设备直接挂在CPU上，实现CPU与高速I/O设备之间的高速数据交换。 PCI总线​ 随着图形用户接口（Graphical User Interface ，GUI）和多媒体技术在PC系统的广泛应用，ISA总线和EISA总线由于受带宽的限制，已不能适应系统工作的要求，成为整个系统的主要瓶颈。因此对总线提出了更高的性能要求，促使总线技术进一步发展。​ 1991年下半年，Intel公司首先提出PCI（Peripheral Component Interconnect ，外部部件互连）总线的概念，并联合IBM、COMPAQ、APPLE、DEC、AST、HP等计算机业界大户，成立了PCI集团PCIIG（PIC Special Interest Group)，于1992年6月22日推出了PCI1.0版，1995和1999又先后推出了2.1和2.2版，PCI总线已成为现代计算机中最常用的总线之一，其主要特点如下： 1. ​ 高性能。PCI总线是一种不依附某个具体处理器的局部总线。它为系统提供了一个高速的数据传输通道，与CPU时钟频率无关，自身采用33MHz和66MHz的总线时钟，数据线为32位，可扩展到64位，传输速率从132MBps可升级到528MBps。它支持突发工作方式，这种方式是指若被传送的数据在主存中连续存放，则在访问此组数据时，只需给出第一个数据的地址，占用一个时钟周期，其后每个数据的传送各占一个时钟周期，不必每次给出各个数据的地址，因此可提高传输速率。 2. 良好的兼容性。PCI总线部件和插件接口相对于处理器是独立的，它支持所有的目前和将来不同结构的处理器，因此具有相对长的生命周期。PCI总线与ISA、EISA总线均可兼容，可以转换为标准的ISA和EISA。 3. 支持即插即用（Plug and play)，即任何扩展卡只要插入系统便可工作。PCI设备中配有存放设备具体信息的寄存器，这些信息可供BIOS和操作系统层的软件自动配置PCI总线部件和插件，使系统使用方便，无需进行复杂的手动配置。 4. ​ 具有与处理和存储器子系统完全并行操作的能力。PCI总线可视为CPU与外设之间的一个中间层，它通过PCI桥路与CPU相连。PCI桥路有多级缓冲，可把一批数据快速写入缓冲器中，在这些数据不断写入PCI设备过程中，，可真正实现与处理器/存储器子系统的安全并发工作。 5. 支持多主设备能力。主设备即对总线有控制权的设备，PCI支持多主设备，即允许任何主设备和从设备之间实现点对点对等存取，体现了接纳设备的高度灵活性。 6. 提供数据和地址奇偶校验功能，保证了数据的完整和准确。 7. 支持两种电压标准：5V和3.3V。3.3~5V的组件技术可以是电压平滑过渡。3.3V电压的PCI总线可以用于便携式微型计算机中。 8. 可扩充性好。当PCI总线驱动能力不足时，可以采用层次结构。 9. 软件兼容性好。PCI部件可以完全兼容现有的驱动程序和应用程序。设备驱动程序可被移植到各类平台上。 10. 采用多路复用技术，减少了总线引脚个数。随着网络的告诉法杖以及其他周边设备的技术革新，诸如千兆网卡之类的设备对PCI总线提出了更高的要求。Intel公司近年来又推出了PCI-Express总线，它采用了类似网络传输TCP/IP协议的分层结构和数据帧逐层传递的模式。 AGP总线​ 随着多媒体计算机的普及，对三维技术的应用也越来越广。处理三维数据不仅要求有惊人的数据量，而且要求有更宽广的数据传输带宽。Intel于1996年7月又推出了AGP（Accelerated Graphics Port），这是显示卡专用的局部总线，基于PCI2.1版规范并进行扩充修改而成，它采用点对点通道方式，以66.7MHz的频率直接与主存联系，以主存作为帧缓冲器，实现了高速存取。最大数据传输率为266MBps，是传统PCI总线带宽的2倍。AGP还定义了一种“双激励”（Double Pumping）的传输技术，能在一个时钟的上，下沿双向传递数据，这样，AGP实现的传输频率为133MHz，最大数据传输率可增为533MBps。后来又依次推出了AGP2X, AGP4X, AGP8X多个版本，数据传输速率可达2.1GBps。 RS-232C总线​ RS-232（RS即Recommended Standard ，232位标识号，C表示修改次数）是由美国电子工业协会EIA（Electronic Industries Association）推荐的一种串行通信总线标准，它是应用串行二进制交换的数据终端设备和数据通信设备之间的标准接口。​ 众所周知，计算机之间传送的是数字信号，它要求传送的频带很宽，而计算机远程通信通常是通过载波电话传送的，不可能有这样的宽的频带。如果数字信号直接进行通信，经过传输后，必然发生畸变。因此在发送端必须通过调制器将数字信号转换成模拟信号，即对载波电话线上载波进行调制；而在接收端又必须用解调器检出从发送端来的模拟信号，并恢复为原来的数字信号。 USB总线​ USB（Universial Serial Bus）通用串行总线是Compaq，DEC，IBM，Intel，Microsoft，NEC（Japan）和Northe Telecom（Canada）等七大公司于1994年11月联合开发的计算机串行接口总线标准，1996年1月颁布了USB1.0版本。它基于通用连接技术，实现外设的简单快速连接，达到方便用户、降低成本、扩展PC连接外设范围的目的。用户可以将几乎所有的外设装置，包括显示器、键盘、鼠标、打印机、扫描仪、数码相机、U盘、调制解调器等直接插入标准USB插口。还可以将一些USB外设进行串接，使一大堆设备共用PC上的端口。其特点如下： 1. 具有真正的即插即用特征。用户可以在不关机的情况下很方便地对外设实行安装和拆卸，主机可按外设的增删情况自动配置系统资源，外设装置驱动程序的安装，删除均自动实现。 2. 具有很强的连接能力。使用USB HUB（USB集线器）实现系统扩展，最多可链式连接127个外设到同一系统。 3. 数据传输率有两种，即采用普通无屏蔽双绞线，速度可达1.5Mbps，若用带屏蔽的双绞线，速度可达12Mbps。USB2.0的数据传输率最高可达480Mbps。 4. 标准统一。USB的引入减轻了对目前PC中所有标准接口的需求，如串口的鼠标、键盘、并口的打印机、扫描仪、IDE接口的硬盘，都可以改成以统一的USB标准接入系统，从而减少了对PC插槽的需求，节省空间。 5. 连接电缆轻巧，电源体积缩小。USB使用的4芯电缆2条用于信号连接，2条用于电源/地，可为外设提供+5V的直流电源，方便用户。 6. 生命力强。USB是一种开放型的不具有专利版权的工业标准，它是由一个标准化组织“USB实施者论坛”制定出来的，因此不存在专利版权问题，USB规范具有强大的生命力。","categories":[{"name":"computer hardware","slug":"computer-hardware","permalink":"http://yoursite.com/categories/computer-hardware/"}],"tags":[],"author":"Virux"},{"title":"bus","slug":"Bus","date":"2021-04-21T09:06:31.000Z","updated":"2021-04-21T15:02:55.727Z","comments":true,"path":"2021/04/21/Bus/","link":"","permalink":"http://yoursite.com/2021/04/21/Bus/","excerpt":"","text":"what is bus： 总线是连接各个部件的信息传输线，是各个部件共享的传输介质。 总线上信息传送： ​ 串行，并行（需要多条数据线） 传输距离较长时不使用并行传输，一般用在机箱内。 总线结构的计算机举例： 1：单总线结构框图：总线会成为瓶颈 2：面向CPU的双总线结构 DEFEAT：当主存要与外部设备，一定要经过CPU，会打断CPU的执行。 3：以存储器为中心 总线分类：（要有标准） 根据总线的位置进行划分： 1：片内总线： 芯片内部总线 2：系统总线： 计算机各部件之间的信息传输线 数据总线 双向 与机器字长、存储字长有关 地址总线 单向 与存储地址、I/O地址有关,一般与MAR的长度相同 控制总线 有出 有入 3：通信总线：用于计算机系统之间或计算机系统与其他系统（如控制仪表、移动通信等）之间的通信 传输方式：并行和串行 总线的特性及性能指标： 一：总线的物理实现 二：总线特性 机械特性 电器特性 传输方向和有效的电平范围 功能特性 每根传输线的功能 时间特性 信号的时序关系 总线的性能指标： 总线的宽度 数据线的根数 标准传输率 每秒传输的最大字节数（MBps） 时钟同步/异步 同步、不同步 总线复用 地址线和数据线复用 （8086地址线和数据线复用）复用的是为了减少芯片的管角、脚数 信号线数 地址线 数据线和控制线的总和 总线控制方式 突发、自动、仲裁、逻辑、计数 其他指标 负载能力 总线标准： 单总线结构 多总线结构 通道：具有特殊功能的处理器，有自己的控制器，指令系统。通道的程序由操作系统来编写。 三总线结构 另一种三总线结构： 四总线结构 将低速设备和高速设备进行分类组织 总线结构举例： 总线控制（重难点） 一：总线判优控制 1.基本概念 主设备（模块） 对总线由控制权 从设备（模块） 响应从主设备发来的总线命令 总线判优控制： 集中式 ：链式查询，计数器定时查询，独立请求方式 分布式： 链式查询：一般用于微型计算机和嵌入式系统 如果I/O接口有总线占用请求，通过BR向总线控制部件提出占用请求。 BG设备查询接口是否总线占用请求。 某个获得授权的接口通过BS总线设置总线忙，然后就获得总线的使用权。 如果BG发送的信号经过某个故障接口时无法传下去，则后续的接口无法查询得到。 计数器定时查询 设备地址上传输的是一个计数器给出的。通过的设备查找某个设备是否提出了总线占用请求。 总线控制部件中有一个计数器。 计数器在总线允许被占用的情况下启动。 优点：优先级的确定十分灵活，可通过软件的方式控制计数器 独立请求方式 每个接口都有BG 和BR两条线，总线控制部件内部有一个排队器。这样优先级的设定十分灵活 接口BR发送总线占用请求信号到总线控制器。 控制部件会对所有请求总线的接口中的某一个应答。获得应答的设备便占有总线的使用权。 二：总线的通信控制 目的： 解决通信双方的 协调配合 问题","categories":[{"name":"computer hardware","slug":"computer-hardware","permalink":"http://yoursite.com/categories/computer-hardware/"}],"tags":[],"author":"Virux"},{"title":"ROM types","slug":"ROM types","date":"2021-04-21T09:02:12.000Z","updated":"2021-04-21T15:05:39.866Z","comments":true,"path":"2021/04/21/ROM types/","link":"","permalink":"http://yoursite.com/2021/04/21/ROM%20types/","excerpt":"","text":"掩模型只读存储器（Masked ROM，MROM）：重合法驱动，根据其交叉处是否有耦合元件MOS管识别0和1.不可写入。 可编程只读存储器（Programmable ROM)：根据熔丝断和未断可区别其所存的信息是0还是1.只能实现一次编程，不得在修改。 可擦除可编程只读存储器（Erasable Programmable ROM)：由浮动栅雪崩注入型MOS管构成，又称FAMOS型EPROM。用户需重新改变其状态，可用紫外线照射，驱散浮动栅，再按需要将不同的位置的MOS管D端重新置于正电压，又得出新状态的ROM。另外还可以使用电器方法将存储内容擦除。 用电可擦除可编程只读存储器（Electrically Erasable Programmable ROM）：可在联机条件下，用字擦除方式或页擦除方式，即可局部擦写，又可全部擦写，这种EPROM就是EEPROM。 闪速存储器（Flash Memory）擦除，重写速度快。在便携式计算机、工控系统及单片机系统中得到大量应用，近年来将它用于微型计算机中存放I/O驱动程序和参数。","categories":[{"name":"computer hardware","slug":"computer-hardware","permalink":"http://yoursite.com/categories/computer-hardware/"}],"tags":[],"author":"Virux"},{"title":"MOS and TTL","slug":"MOS and TTL","date":"2021-04-21T08:59:46.000Z","updated":"2021-04-21T15:05:17.888Z","comments":true,"path":"2021/04/21/MOS and TTL/","link":"","permalink":"http://yoursite.com/2021/04/21/MOS%20and%20TTL/","excerpt":"","text":"MOS：金属氧化半导体场效应晶体管 TTL：Transistor-Transistor logic 晶体管-晶体管逻辑电路","categories":[{"name":"computer hardware","slug":"computer-hardware","permalink":"http://yoursite.com/categories/computer-hardware/"}],"tags":[],"author":"Virux"},{"title":"develpment aspects of microprocessors","slug":"develpment aspects of microprocessors","date":"2021-04-21T08:37:57.000Z","updated":"2021-04-21T15:03:55.958Z","comments":true,"path":"2021/04/21/develpment aspects of microprocessors/","link":"","permalink":"http://yoursite.com/2021/04/21/develpment%20aspects%20of%20microprocessors/","excerpt":"","text":"从21世纪初来看，当前通用微处理器的发展重点将在以下几个方面： 进一步提高复杂度来提高处理器性能 通过Thread-level/Process-level 并行性的开发提高处理器的性能，即通过开发线程级并行性（Thread-Level Parallelism，TLP）或进程级并行性（Process-Level Parallelism，PLP）来提高性能，简化硬件设计。 将存储器集成到处理器芯片来提高处理器性能 发展嵌入式处理器","categories":[{"name":"computer hardware","slug":"computer-hardware","permalink":"http://yoursite.com/categories/computer-hardware/"}],"tags":[],"author":"Virux"},{"title":"traversal of binary tree","slug":"traversal of binary tree","date":"2021-04-21T08:33:26.000Z","updated":"2021-04-21T15:06:13.457Z","comments":true,"path":"2021/04/21/traversal of binary tree/","link":"","permalink":"http://yoursite.com/2021/04/21/traversal%20of%20binary%20tree/","excerpt":"","text":"Chain storage definition1234typedef struct BiTNode&#123; ElemType data; struct BiTNode *lchild,*rchild;&#125;BitNode,*BiTree; PreOrder (recursive)1234567void preOrder(BiTree T)&#123; if(T!=null)&#123; visit(T); preOrder(T-&gt;lchild); preOrder(T-&gt;rchild); &#125;&#125; InOrder (recursive)1234567void inOrder(BiTree T)&#123; if(T!=null)&#123; inOrder(T-&gt;lchild); visit(T); inOrder(T-&gt;rchild); &#125;&#125; AfterOrder(recursive)1234567void afterOrder(BiTree T)&#123; if(T!=null)&#123; afterOrder(T-&gt;lchild); afterOrder(T-&gt;rchild); visit(T); &#125;&#125; InOrder(non-recursive)123456789101112131415void inOrder(BiTree T)&#123; initStack(S); //initialize a stack BiTree p=T; // moving pointer while(p||!isEmpty(S))&#123; if(p)&#123; push(S,p); p=p-&gt;lchild; &#125; else&#123; pop(S,p); visit(p); p=p-&gt;rchild; &#125; &#125;&#125; PreOrder(non-recursive)1234567891011121314void afterOrder(BiTree T)&#123; initStack(S); //initialize a stack BiTree p=T; while(p||!isEmpty(S))&#123; if(p)&#123; visit(p); push(S,p); p=p-&gt;lchild; &#125;else&#123; pop(S,p); p=p-&gt;rchild; &#125; &#125;&#125; LevelOrder12345678910111213void levelOrder(BiTree T)&#123; InitQueue Q; //initialize a queue; BiTree p; enQueue(Q,p); while(!isEmpty(Q))&#123; deQueue(Q,p); visit(p); if(p-&gt;lchild!=null) enQueue(Q,p-&gt;lchild); if(p-&gt;rchild!=null) enQueue(Q.p-&gt;rchild); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[],"author":"Virux"},{"title":"Bochs usage","slug":"Bochs usage","date":"2021-04-21T08:22:35.000Z","updated":"2021-04-21T15:02:49.259Z","comments":true,"path":"2021/04/21/Bochs usage/","link":"","permalink":"http://yoursite.com/2021/04/21/Bochs%20usage/","excerpt":"","text":"Introduction​ Bochs is a virtual machine, which is kind of different from other virtual machine software, like VirtualBox and VMware. The most distinctive point is that it can debug kernel codes. So, its usage may not friendly. Before using it to virtualize physical machine, it need configuring a configure file, which contains many parameters you want to emulate. Downloading websitehttp://bochs.sourceforge.net/ NOTE: dlxlinux, demo of usage , of version 2.6.11 can’t be successfully run. Usage​ Using Bochs to debug, two files are inevitable and should be generated manually, configure file and image file.​ For config file, the following is an example. Each parameter’s meaning can be looked up from bochsrc-smaple.txt in Bochs directory. 123456789101112131415161718192021222324252627282930313233343536373839# how much memory the emulated machine will havemegs: 32# filename of ROM imagesromimage: file=../BIOS-bochs-latestvgaromimage: file=../VGABIOS-lgpl-latest# what disk images will be used floppya: 1_44=floppya.img, status=insertedfloppyb: 1_44=floppyb.img, status=inserted# hard diskata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14ata0-master: type=disk, path=\"a.img\", cylinders=306, heads=4, spt=17# choose the boot disk.boot: c# default config interface is textconfig.#config_interface: textconfig#config_interface: wx#display_library: x# other choices: win32 sdl wx carbon amigaos beos macintosh nogui rfb term svga# where do we send log messages?log: bochsout.txt# disable the mouse, since DLX is text onlymouse: enabled=0# set up IPS value and clock synccpu: ips=15000000clock: sync=both keyboard: keymap=../keymaps/x11-pc-us.map#keyboard: keymap=../keymaps/x11-pc-fr.map#keyboard: keymap=../keymaps/x11-pc-de.map#keyboard: keymap=../keymaps/x11-pc-es.map ​ For image file, it could be floppy, hard disk and CDROM, all of which should be written with binary file which can appear with NASM compiling .asm file to .bin file.​ To utilize debug function, open bochsdbg.exe.","categories":[{"name":"OSDev","slug":"OSDev","permalink":"http://yoursite.com/categories/OSDev/"}],"tags":[],"author":"Virux"},{"title":"kernel","slug":"kernel","date":"2021-04-21T08:17:15.000Z","updated":"2021-04-21T15:05:00.108Z","comments":true,"path":"2021/04/21/kernel/","link":"","permalink":"http://yoursite.com/2021/04/21/kernel/","excerpt":"","text":"Into Protection Mode12345678910111213141516171819202122232425From real mode into protection mode, there are five necessary steps:1: load global descriptor register xor eax,eax mov ax,cs shl eax,4 add eax,LABEL_GDT mov dword [GdtPtr+0x02],eax lgdt [GdtPtr]2: switch off interrupt cli 3: open A20 in al,92h or al,0000_0010h out 92h,al4: set PE in cr0 to 1 mov eax,cr0 or eax,1 mov cr0,eax 5: jump into protected mode jmp dword SelectorCode32:0 Set up paging12341: initialize page directory table and page page table.2: set cr3 to the initial position of page directory table3: set the PG -the highest bit in CR0 to 14: nop Interrupt under protected mode121:Interrupt Descriptor Table(IDT) replaces Interrupt Vector(IVT).2:BIOS interrupt is invalid. Interrupt and Exception12345Exception has three forms:Fault , Trap , AbortInterrupt has two forms:external interrupt(whether to be maskable) , int n Special descriptor in GDT123451: Local descriptor table(LDT) descriptor2: Task-state segment(TSS) descriptor3: Gate descriptor4: Page directory descriptor5: Page table descriptor Pass parameters with STACK12 FAT12 recognized by Linux1If we organize a floppy with FAT12, it needn't writing for .bin file with dd. This floppy can be mounted then we use cp to copy file into this floppy. Linux will automatically complete root directory,FAT1 and FAT2. what’s going to do in loader1234561: get memory info2: find out kernel.bin in root directory and load it3: into protect mode4: display memory info (not necessary)5: set up paging 6: after loading kernel into memory, place it according to program header table. BIOS Interrupt1234567891011121314151617181920int 10h ah=13hFunction: display charal:output patternbl:display propertybh:page numbercx:string lengthdh:row dl:coles:bp string addressint 13h ah=02hFunction: read sectional:how many sections to reades:bx buffer addressch: cylinder numbercl: section numberdh: header numberdl: driveroutput:CF=0 succeed. ah=0 al=how many section to read","categories":[{"name":"OSDev","slug":"OSDev","permalink":"http://yoursite.com/categories/OSDev/"}],"tags":[],"author":"Virux"},{"title":"proving process of number relationship between child and parent in tree","slug":"proving process of number relationship between child and parent in Tree","date":"2021-04-21T08:09:32.000Z","updated":"2021-04-21T15:05:32.201Z","comments":true,"path":"2021/04/21/proving process of number relationship between child and parent in Tree/","link":"","permalink":"http://yoursite.com/2021/04/21/proving%20process%20of%20number%20relationship%20between%20child%20and%20parent%20in%20Tree/","excerpt":"","text":"性质表述：如果对一棵有n个结点的完全二叉树的结点按层序编号（从左到右），则对任一结点i，有（1）如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲PARENT(i)是结点$$\\lfloor i/2 \\rfloor$$（2）如果2i&gt;n，则结点i无左孩子；否则其左孩子LCHILD(i)是结点2i. （3）如果2i+1&gt;n，则结点i无右孩子；否则其右孩子RCHILD(i)是结点2i+1 证明（数学归纳法）：对于i=1，由完全二叉树的定义，其左孩子结点是2，若2&gt;n则左结点不存在，否则2是它的左孩子结点；同理对结点3也成立对于i&gt;1，分两种情况讨论；（1）若结点i是第j层的第一个结点，那么其左孩子结点应为第j+1层的第一个结点，编号为$$2^j-1+1=2^j=2(2^{j-1})=2i$$同样，若2i&gt;n则i的左孩子不存在，反之存在；同理其有孩子结点为2i+1. （2）若结点i是第j层的某一个结点（不一定第一个结点），由（1）可知，其左右孩子节点分别为2i，2i+1.则对于第i+1个结点， 其左孩子为2i+1+1=2(i+1)，右孩子结点为2(i+1)+1.证毕。","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[],"author":"Virux"},{"title":"concepts and properties of tree","slug":"concepts and properties of tree","date":"2021-04-21T08:01:45.000Z","updated":"2021-04-21T15:03:46.921Z","comments":true,"path":"2021/04/21/concepts and properties of tree/","link":"","permalink":"http://yoursite.com/2021/04/21/concepts%20and%20properties%20of%20tree/","excerpt":"","text":"1. Basic concepts节点和树的度（Degree）树中一个结点的孩子个数称为该节点的度。树中节点的最大度数称为树的度。 树的层次（Level），深度（Depth）和高度严蔚敏的书规定，根节点所在的层次是第一层。故，深度=高度。 有序树和无序树若将树中结点的各子树看成从左至右有次序的（即不能互换），则称该树为有序树，否则为无序树。 路径和路径长度树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的，而路径长度是路径上所经过的边的个数。树的路径长度是从树根到每个结点的路径长度。 2. Basic properties任意树的结点数与其最小高度的关系具有n个结点的m叉树的最小高度为：$$\\lceil\\log_m (n(m-1)+1)\\rceil$$ 二叉树与度为2的有序树的区别 度为2的树至少有3个结点，而二叉树可以为空 度为2的有序树的孩子的左右次序是相对于另一孩子而言的，若某个结点只有一个孩子，则这个孩子就无须区分其左右次序，而二叉树无论孩子数是否为2，均需确定其左右次序，即二叉树的结点次序不是相对另一结点而言，而是确定的。 二叉树结点关系(常用)非空二叉树上的叶子结点数等于度为2的结点数加1，即$$n_0=n_2+1$$ 某一层的结点数上限非空二叉树第k层上至多有$$2^{k-1}个结点$$ 对于完全二叉树，确定结点数n，即确定高度$$h=\\lceil\\log_2(n+1)\\rceil或 \\lfloor\\log_2n\\rfloor+1$$ 完全二叉树某一结点的深度编号为i的结点所在的深度为$$\\lfloor\\log_2i\\rfloor+1$$ 完全二叉树奇偶结点数若n为奇数，则每个分支节点都有左孩子和右孩子；若n为偶数，则编号最大的分支节点（编号为n/2）只有左孩子，没有右孩子，其余分支节点左，右孩子都有。","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[],"author":"Virux"},{"title":"MIPS addressing modes","slug":"MIPS addressing modes","date":"2021-04-21T07:46:32.000Z","updated":"2021-04-21T15:05:12.309Z","comments":true,"path":"2021/04/21/MIPS addressing modes/","link":"","permalink":"http://yoursite.com/2021/04/21/MIPS%20addressing%20modes/","excerpt":"","text":"立即数寻址立即数寻址(immediate addressing)，操作数是位于指令自身的常数。 寄存器寻址寄存器寻址(register addressing)，操作数是寄存器。 基址寻址基址寻址(base addressing)或偏移寻址(displacement addressing)，操作数在内存中，其地址是指令中基址寄存器和常数的和。 PC相对寻址PC相对寻址(PC-relative addressing)，地址是PC和指令中常数的和。 伪直接寻址伪直接寻址(pseudodirect addressing)，跳转地址由指令中26位字段和PC高位相连而成。","categories":[{"name":"computer hardware","slug":"computer-hardware","permalink":"http://yoursite.com/categories/computer-hardware/"}],"tags":[],"author":"Virux"},{"title":"memory","slug":"memory","date":"2021-04-21T07:30:45.000Z","updated":"2021-04-21T15:08:04.494Z","comments":true,"path":"2021/04/21/memory/","link":"","permalink":"http://yoursite.com/2021/04/21/memory/","excerpt":"","text":"一. 存储器分类 （1） 半导体存储器 TTL 、MOS 易失 （2）磁表面存储器 磁头，磁载体 非易失 （3） 磁芯存储器 硬磁材料 ，环状元件 非易失 （4） 光盘存储器 激光 、激光材料 非易失 寄存器在I/O端口中也有 Cache 一部分在CPU中，一部分在CPU外 利用软硬件相结合的方式将不同介质的存储器连接成一个整体。 主存-辅存 解决主存容量不够 。利用软硬件相结合的方法连接成一个整体。 缓存-主存 为了解决主存的速度不够。用硬件的方法连接成一个整体。因为主要是为了解决主存和CPU的速度问题，故需要非常快。 主存-辅存 这个整体称为虚拟存储器。地址称为：虚地址，逻辑地址 缓存-主存 这个层次结构用主存储器的地址。实际上缓存是按内容来查找的。 主存用到的地址称为实地址，也即物理地址。 Q1：主存的基本组成 Q2：主存与CPU之间的联系 Q3：主存中存储单元地址的分配 Q4：主存的技术指标 主存的基本构成：存储体，MAR，MDR，译码器等。 MAR经过译码器进行译码才能选定指定的存储单元。 主存遍址单位是字节，每一个字节都一个地址。 12345678H 在主存的存储单元中如何存储。 高位字节地址为字地址（高位字节在低地址，低位字节在高地址）-大端方式 低位字节地址为字地址-小端方式 x86系列的机器采用的是小尾方式。 两种类型的机器进行通讯会产生问题。 读出时间：从给出地址信号到数据线有稳定的数据输出。 存取周期&gt;存取时间 半导体芯片的片选线一般有两种方式： 对 八个芯片相同的地址同时进行操作，每个芯片给出一位。每一组八个芯片要同时进行工作才能够在每个芯片当中读出或写入一位二进制信号。每八片的片选线连接在一起。CPU地址中016K-1 分配到第一组芯片中。16K32K-1 分配到第二组芯片中。后面同理 如果要读的地址是65535，则选择第四组芯片（低电平有效），其余芯片组高电平。然后在八个芯片的同一地址处各读出一位，构成一个B，送到CPU中。 半导体存储芯片的译码驱动方式 线选法：不适合地址容量大的内存，布局的时候，是布局成线性的数组。 重合法：把所有的存储单元布局成二位的存储阵列，可以提高芯片集成度。 RAM：内存就是由RAM构成的。 静态RAM（SRAM） 动态RAM（DRAM） 静态RAM:利用触发器存储0,1(1)：静态RAM基本电路的读操作的解释","categories":[{"name":"computer hardware","slug":"computer-hardware","permalink":"http://yoursite.com/categories/computer-hardware/"}],"tags":[],"author":"Virux"},{"title":"C head file contents","slug":"C head file contents","date":"2021-04-21T07:12:21.000Z","updated":"2021-04-21T15:03:40.629Z","comments":true,"path":"2021/04/21/C head file contents/","link":"","permalink":"http://yoursite.com/2021/04/21/C%20head%20file%20contents/","excerpt":"","text":"明示常量——例如，stdio.h中定义的EOF，NULL和BUFSIZE（标准I/O缓冲区大小） 宏函数——例如，getc(stdin) 通常用getchar()定义，而getc()经常用于定义较复杂的宏，头文件ctype.h通常包含ctype系列函数的宏定义 函数声明——例如，在string.h头文件包含字符串函数系列的函数声明。在ANSI C和后面的标准中，函数声明都是函数原型形式。 结构模板定义——标准I/O函数使用FILE结构，该结构中包含了文件和与文件缓冲区相关的信息。FILE结构在头文件stdio.h中。 类型定义——标准I/O函数使用指向FILE的指针作为参数。通常，stdio.h用#define或typedef把FIEL定义为指向结构的指针。类似地，size_t和time_t类型也定义在头文件中。","categories":[{"name":"C","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[],"author":"Virux"},{"title":"English grammar","slug":"English grammar","date":"2021-04-21T05:56:01.000Z","updated":"2021-04-21T15:04:08.518Z","comments":true,"path":"2021/04/21/English grammar/","link":"","permalink":"http://yoursite.com/2021/04/21/English%20grammar/","excerpt":"Common English grammar structures.","text":"Common English grammar structures. needn’t have done and could have done needn’t have done: I needn’t have (done) something = I did something but now I know that it was not necessary. could have done: Most often, we use *could have (done) * for things which were possible but did not happen. Example I got up very early because I had to get ready to go away. But in fact it didn’t take me long to get ready. So, I needn’t have got up so early. I *could have stayed * in bed longer. modals + have donecould (not) have doneMost often, we use could have (done) for things which were possible but did not happen Why did you stay at a hotel when you went to New York?You could have stayed with Barbara. may have done and might have doneBoth of them just express a possibility (whatever positive or negative) A: I wonder why Kay didn’t answer the phone. B: She may have been asleep. A: I was surprised that Sarah wasn’t at the meeting. B: She might not have known about it. NOTE: couldn’t (negative) is different from may not and might not She was too far away, so she couldn’t have seen you.(=it is not possible that she saw you) A: I wonder why she didn’t say hello. B: She might not have seen you. needn’t have doneIt means you really did something but now you know it was not necessary. So, you really did.But ,comparing to could have done ,which means you didn’t do something that could happen probably , this sentence is opposite to could have done. (in a sense). I got up very early because I had to get ready to go away. But in fact it didn’t take me long to get ready. So, I *needn’t have got up * so early. I *could have stayed * in bed longer. should (not) have doneYou didn’t do it but it would have been the right thing to do. (for positive) (positive): It was a great party last night. You *should have * come. Why didn’t you? (negative): I’m feeling sick. I *shouldn’t have eaten * so much chocolate. may and mightWe use may or might to say that something is a possibility. Usually you can use may or mightyou can say: It may be true . or It might be true. She might know. or She might know. Sometimes could has a similar meaning to may and mightBut couldn’t is different from may not ** and **might not. She was too far away, so she couldn’t have seen you . A:I wonder why she didn’t say hello. She might not have seen you. But we use only might (not may) when the situation is not real. If I knew them better, I might invite them to dinner. (The situation here is not real because I don’t know them very well,so I’m not going to invite them.’May’ is not possible in this example) Might as well / may as well What shall we do?Shall we walk? We might as well. It’s a nice day and I don’t want to wait here for an hour. ‘(We) might as well do something’ =(We) should do something because there is nothing better to do and there is no reason not to do it. You can also say ‘may as well (do)’. A: What time are you going? Well , I’m ready, so I might as well go now. difference between will and going towill: We use will when we decide to do something at the time of speaking. The speaker has not decided before. The party is a new idea. For example: SUE: Let’s have a party. HELEN: That’s a great idea. We‘ll invite lots of people. going to: We use going to when we have already decided to do something. Helen had already decided to invite lots of people before she spoke to Dave. For example: HELEN: Sue and I have decide to have a party. We‘re going to invite lots of people. could and was/were able toWe use could to say that somebody had the general ability or permission to do something: My grandfather could speak five languages. We were completely free. We could do what we wanted. We use could for general ability. But if we are talking about what happened in a particular situation , we use was/were able to… or managed to…(not could): The fire spread through the building quickly but everybody was able to escape.or…everybody managed to escape. They didn’t want to come with us at first but we managed to persuade them.or…we were able to persuade them.(but not ‘could persuade’) Compare: Jack was an excellent tennis players. He could beat anybody. (=he had the general ability to beat anybody) but Jack and Alf had a game of tennis yesterday. Alf played very well but in the end Jack managed to beat him. or…was able to beat him. (=he managed to beat him in this particular game) could and could havecould:** use could to talk about possible actions now or in the future (especially to make a suggestion):A: What shall we do this evening? B: We could go to cinema.It’s a nice day. We could go for a walk. You must use could(not ‘can’) when you don’t really mean what you say:I’m so angry with him. I could kill him!(not ‘I can kill him’) We also use could to say that something is possible now or in the future:The phone is ringing. It could be Tim.(now)I don’t know when they ‘ll be here . They could arrive at any time.(future) could have (done) Most often, we use could have (done) for things which were possible but did not happen: Why did you stay at a hotel when you went to New York? You could have stayed with Barbara. (=you had the opportunity to stay with her but you didn’t) Jack fell off a ladder yesterday but he’s all right. He’s lucky - he could hurt himself badly. (but he didn’t hurt himself) Jack wanted Ken to lend him 50 last week.Ken couldn’t have lent him 50. (because he was short of money) as as…as Any sentences using the structure as…as can rewrite a sentence with than. And the meaning doesn’t change. The city center wasn’t as crowded this morning as it usually is. (subject + verb after the second as) I don’t know as many people as you do. (between the first and the second as ,it’s many+ noun, usually it should be a adj or adv, many/much+ noun can be an exception.) Note: It’s not necessary that after the second as , it must be subject +verb. Such as: Let’s walk. It’s just as quick as taking the bus. as soon as possible is common: Can you send me the money as soon as possible, please? (Usually, it’s put in the end of sentence). Another form: twice as…as , three times as…as etc: Petrol is twice as expensive as it was a few years age. Their house is about three times as big as ours. the same as is usual, but remember, between ‘same’ and ‘as’, it should be noun. Ann’s salary is the same as mine. or Ann gets the same salary as me. Tom is the same age as George. ‘What would you like to drink?’ ‘I’ll have the same as you.’ As (reason and time), here ‘as ‘ is a conjunction As (reason): As sometimes means ‘because’: As it was a public holiday, all the shops were shut. (=because it was a public holiday) As the live near us, we see them quite often. We watched television all evening as we had nothing better to do. As(time): more complicated than above. you can say that something happened as you were doing something else (= in the middle of doing something else): Jill slipped as she was getting off the bus. The thief was seen as he was climbing over the wall. Most often we use as when two short actions happen at the same time: George arrived as Sue left. (=he arrived and Sue left at the same time) We all waved goodbye to Liz as she drove away in her car. But we also use as when two things happen together over at longer period of time: As the day went on, the weather got worse. I began to enjoy the job more as I got used to it. You can also use just as (=exactly at that moment): Just as I sat down, the phone rang. Just as we were going out, it started to ran. I had to leave just as the conversation was getting interesting. We use as(time) for actions and happenings. As + a situation (not an action) usually means ‘because’: As we were asleep, we didn’t hear the doorbell. (=because we were asleep) As I walked into the room, the phone started ringing. (at the same time) As they live near me, I see them quite often. (=because they live near me) Another use: We use as before a subject + verb: I didn’t move anything. I left everything as I found it. They did as they promised. We also say as you know/as I said/ as she expected/ as I thought etc: As you know, it’s Tom’s birthday next week. (‘As part’ is put in the head) Jane failed her driving test, as she expected. Note that we say as usual / as always: You’re late as usual. as long asas long as , so long as , provided , providing All these expressions mean ‘if’ or ‘on condition that’ You can use my car as(so) long as you drive carefully. Travelling by car is convenient provided (providing) you have somewhere to park. *Providing (Provided) * she studies hard, she’ll pass her exams. When you are talking about the future, do not use will after unless / as long as / provided / providing.Use a present tense. in case (of)Some examples of in case: Ann might phone tonight. I don’t want to go out in case she phones. I’ll draw a map for you incase you can’t find our house. We use just in case for a smaller possibility: I don’t think it will rain but I’ll take an umbrella just in case. ‘In case of…’ is not the same as ‘in case’. In case of=’if there is…’(especially in notices etc.): In case of fire, please leave the building as quickly as possible. In case of emergency, telephone this number. the… the …It’s comparison structure. We use it to say that one thing depends on another thing: The warmer the weather, the better I feel. The sooner we leave, the sooner we will arrive. The younger you are, the easier it is to learn. The more expensive the hotel, the better the service. Note: 本质来说，前后两个the 句子都是一个完整的正常语序的句子在进行倒装，同时由上述例子可以看出，will be /be 可以省略。 older and elderThe comparative of old is older: Tom looks older than he really is. You can use elder(or older) when you talk about people in a family. You can say (my) elder brother/sister/son/daughter: My elder brother is a pilot. We say ‘my elder brother’ but we don’t say that ‘somebody is elder’: My brother is older than me(not ‘elder than me’)","categories":[{"name":"grammar","slug":"grammar","permalink":"http://yoursite.com/categories/grammar/"}],"tags":[],"author":"Virux"},{"title":"x86 instruction","slug":"x86 Instructions","date":"2021-04-20T06:47:01.000Z","updated":"2021-04-21T15:15:50.140Z","comments":true,"path":"2021/04/20/x86 Instructions/","link":"","permalink":"http://yoursite.com/2021/04/20/x86%20Instructions/","excerpt":"","text":"Master boot sector123456//Nomally, 0 head 0 cylinder 1 sector is the Master boot sector//to prevent reading fault data, master boot sector's last two binary//must be 0x55aa//use db or dw can complete itdb 0x55,0xaadw 0xaa55 //cause,write a word into memory with low byte alignment div(process unsigned number)12345678910111213141516// div has two different methods to use// div followed by regiseter or memoryaddress // No1: 16-bit dividend is divided by 8-bit divisor//the 16-bit dividend need loading into ax//quotient in al , remainder in ahdiv cldiv byte [0x0023]// No2: 32-bit dividend is divided by 16// under this situation, divident can't be placed in ax//so,it's divided two parts, the hightest 16 bit is placed in dx// the lowest 16 bit is placed in ax// then,quotient in ax , remainder in dxdiv cxdiv word [0x0230] mul1234//It makes the value contained in parameter multiply al or ax.Bit width should be identical. If al ,put result into ax, while if ax , put result into dx:ax//parameter can be regs or memaddrmul bxmul word [0x2000] idiv(process signed number)1234567891011//when caculating signed number division, especially 32 bit dividend, dx's value need notingxor dx,dxmov ax,0xf0c0mov bx,0x10idiv bl//WRONG!dx:ax=0000 f0c0,dx:ax is a positive number//Correct waymov ax,0xf0c0cwdmov bx,0x10idiv bl xor12345//xor has two parameters, the first of which should be register or memAddress//the second of which could be register , memAddress or immediate.//But they couldn't be immediate or memAddress at the same time.//Both of parameters have the same bit width.xor word [0x2002], 0x55aa infinite loop1infi: jmp near infi times (pseudo)123//this pseudoinstruction repeat its following instructions with many timestimes 20 mov ax,bxtimes 203 db 0 / : line continuation1234// In NASM, '\\' is line continuation. When a single line can't contain all codes, '\\' is put in line rear, which indicates this line and the next line shouble be conbined into a line.mytext: db 'L',0x07,'b',0x07,'a',0x07,'e',0x07,'l',0x07,' ',0x07,'o',0x07,\\ 'f',0x07,'f',0x07,'s',0x07,'e',0x07,'t',0x07,':',0x07 movsw,movsb,cld(clear direction flag),std(set direction flag),rep1234567891011121314151617// Both of them can make bulk transfer from one memory address to another address. movsw transfers a word once while movsb delivers a byte at a time. The destination, starting point and times of transfer depend on ES:DI, DS:SI and CXmov ax,0x7c0mov ds,ax mov ax,0xb800mov es,axcld //this instruction is to set FLAGS(register)to indicate //transfer // direction, from low binary to high binary or the opposite // cld sets the tenth bit-direction flag to 0 (positive) //while std have the opposite functionmov si,mytextmov di,0mov cx,(number-mytext)/2rep movsw //rep is a instruction instruction prefix, its following instruction continue working until cx decreases to 0.//NOTE:after movsw, the value of di has been changed, pointing out the empty positioni. lodsb,lodsw*1lodsb or lodsw transfer a byte or a word into al or ax in accordance with the positioin of DS:SI and then increase or decrease SI according to DF(direction flag). stosb, stosw, stosd12345b-&gt;bytew-&gt;wordd-&gt;double wordtransfer eax(byte, word or dword) to es:edithen increase or decrease di according to DF loop1234//Two steps it will make://the first is to descrease cx by one;//the other is checking out wheter to continue loop on the value of cx.loop label $1234567//$ is label offered by NASM. It represents the offset of current line.jmp near $ // equal to infi: jmp near infi//$$ represents the assembly address of current assembly segment.times 510-($-$$) db 0db 0x55,0xaa//the two line can fill master boot sector so that the last two binary can be recognized as the flag of master boot sector. neg(negative)123//neg is used to convert a number to its opposite//al=8neg al // al=-8 cbw(Convert Byte to Word),cwd(Convert Word to Double-Word)1234//cbw will extend a signed number in al into ax while cwd extend a signed number in ax into dx:ax. Actually, it just fills ah or dx with signed bit of al or ax//NOTE: cbw and cwd don't have operand with implicit operand-al or ax.cbwcwd jns , js123456//jns is a conditional branch instruction based on SF(sign flag) of FLAGS(flag register). //Many arithmetic and logical instruction can sway SF, such as add, sub, xor and so on. When the highest bit of a result outputted by A&amp;L instruction is 1, CPU will set SF to 1, while set 0 under the other situation.// SF=0, jns vaild, tranferring//ZF(zero flag) be set when result is 0dec sijns show jo,jno,jc,jnc,jp,jnp1// all of them similar to jns and js jcxz (jump if cx is zero)1// cmp12345//compare two operands, not keep result but set flag bit in accordace with resultcmp al,0x08 equal to sub al,0x08 //but dont keep value into alcmp ax,bx//ax is the hero. We do care about if ax &gt; bx, if ax &lt; bx or if ax = bx.//bx is a baseline. push,pop12345678//push and pop used for munipulating stack(in memory)//There are two steps to define a stack segment://mov ss,ax ;ax=0//mov sp,ax//Both of two instructions just manipulate 16-bit register or memory unit, with 8-bit register impossible//working mechanism://In spite of defining in 0x00000, push stores value after decreasing sp by 2,so, stack grows from top to down-from FFFF0 to 00000.//Because master boot sector is loaded in 0x07c00, stack should be paied attention not to grow into MBS'area, which programmers should control carefully. push (in 32 mode)123456789In 16 mode, push cant have immediate operand, while 32 mode dose.push byte 0x55Whatever in 16 mode or 32 mode, pushing in stack will never be byte 0x55. In 16 mode, 0x0055 is pushed ,while in 32 mode, 0x00000055 is pushed. These work is what compiler dose and transparent to programmer.Although under 32 mode 8-bit immi can be pushed, when it is poped, it couldn't pop to 8-bit register, while into 32-bit register.;under 32-bit mode push byt '.'pop eax ;correct call12345678910111213141516//8086 supports four calling ways//1:Relative near calling: parameters offered by label. It just can call procedure in the same segment.call near proc_1 //near is dispensable.Without near. compiler deems near call.call 0x0500 //different from indirect absolute near calling//2:Indirect absolute near calling: parameter offered by regs or memcall cxcall [0x3000]//3:Direct absolute far calling: parameter offered by two parts, the first of which is offset while the other is segement base address. It can call procedure from inter-segment.call 0x2000:0x0030 //0x2000 is offset ,0x0030 is base address//4.Indirect absolute far calling, keyword far is necessary.parameter offered by regs or mem.call far [bx]call far [proc_1] ;proc_1 dw 0x0102,0x2000 //0x0102 offset 0x2000 base add jmp (unconditional)12345678910111213141516171819//five different ways//1: relative short jmp: jump range is 8-bit lengthjmp short infinite //short is necessary//2: 16-bit relative near jump: jump range is 16-bit lengthjmp near infinite //near can be removed, compiler generates machine code //with regard to jmp's length of parameter//3: 16-bit indirect absolute jump: its parameter is regs or memAddr which offers real offset that needn't caculating by compiler,which means the offset will be sent to IP directly jmp near bx jmp [jump_dest] //jump_dest dw 0xc000 //4: 16-bit direct absolute far jump: jmp 0x0000:0x7c00 //0x0000 base addr put in CS directly, 0x7c00 offset // put in IP directly//5: 16-bit indirect absolute far jump: access to memory to get segment basic address and intro-segment offset, not register. jump_far dw 0x33c0,0xf000 //0x33c0 offset 0xf000 basic addr jmp far [jump_far] // far is indispensable ret,retf1234567//ret is near return while retf is far return//when executing ret, stack will pop a 16-bit operand to IP//but when retf, stack will pop two words into CS and IP//NOTE: So-called stack is just current segment's stack which can be accessed by sp and ssretretf// for retf, the fisrt pop is ip the second is cs cli, sti123cli: clear interrupt flag will ignore interruptsti: set interrupt flag will open interruptBoth of them change IF in FLAG register hlt(halt)1no operand, let computer stay in halt situation and low power state test123456789.w0: mov al,0x0a or al,0x80 out 0x70,al in al,0x71 test al,0x80 jnz .w0If the seventh bit of al is 1, then jump to .w0. otherwise,execute sequentially.test actually is similar to 'and' ,set FLAG according result but discard it. [bits 16], [bits 32]1[bits 16] [bits 32] are pseudoinstruction, which indicate default compiling mode. [] is dispensible. org **123org makes label assembly offset plus org's argument.Without org, label represents offset relative to segment or programm start.While with org, such as org 0x7c00, every offset label represents will be added by 0x7c00. %rep1234pre-instruction:%rep 255 Gate SelectorCode 32, SpuriousHandler , 0 , DA_386_IGate%endrep Tips 112//If you want to use register to offer offset, there are just a few registers capable,which are BX,SI,DI,SP. It is a hardware rule.//Besides, instruction mov ax,[bx] is actually equal to mov ax,[ds:bx] while you can appoint segment explicitly, such as mov ax,[es:bx] Tips 2123//Segment reigsters, like ss,cs,ds and es, can't be operand of arithmetic and logical instructions.xor ss,ssadd cs,cs // both wrong Tips 312Logical segment like header,code,data,stack ,is declared with vstart=0.So that,we just need to get this segment base address and then can obtain data there by intro-segment offset. Tips 41When changing the value of ss, cpu will disable interrupt within this instruction and the next instruction. The next instrction is usually to change the value of sp. Disabling interrupt has significance. Imagine that after finishing the change of the value of ss, an interrupt occurs so that the relevant register in current segment must be pushed into stack. However the ss has changed. push into a fault position. Tips 5123Under 32 protected mode, we can point out effective address by using general register (EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI) plus general registers other than ESP, the latter part can multiply a factor (1,2,4,8), and then can add a offsetmov ecx,[eax+ebx*8+0x02] Tips 612345678910111213141516171819202122After finishing global descriptor table, there are some tasks to do for into protect mode.1: resolve historical issue, open A20in al,0x92or al,0000_0010Bout 0x92,al 2: IVT in real mode isn't situable. switch off interruptcli3:cr0 (control register): save flags for controling CPU mode and running situation. The zero bit is Protection Enable. 1 :into protect mode.mov eax,cr0or eax,1mov cro,eax4:from real mode into protect modejmp dword 0x0008:flush ;0x0008 is selector while flush is 32-bit offsetNOTE: dword is to embellish offset and has nothing to do with selector. Tips 71To be compatible with 16-bit real mode, in 16-bit real mode, segment liner base address in descriptor high-speed buffer validate the low 20 bits, while the high 16 bit is invalid. Tips 81With regard to master boot sector, when it is loaded into memory address 0x7c00, whether to use pseudo-instruction org 0x7c00, initially, cs is 0x0000 and ip is 0x7c00. Tips 91If a label starts with dot(.), it's a local label and must follow after global label. Tips 101234567Programm habits: LABEL_SEG_CODE32: ...SegCode32Len equ $-LABEL_SEG_CODE32SegCode32Len: These len label is to set segment limit conveniently Tips 11*1Under real mode, label could be offset relative to the start of programm or segment. However, under protect mode, label must represent offset relative to segment start. Addressing Mode1234567891011121314151617181920212223242526272829//Four modes to address://1. Register Addressingmov ax,cxinc dx//2. Immediate Addressingmov bx,0xf000mov dx,label_a//3. Memory Addressing//3.1 Direct Addressingmov ax,[0x5c0f]add word [0x0230],0x5000 //3.2 Base Addressing//base register:bx bp -offer offsetmov [bx],dxadd byte [bx],0x55mov [bx+0x100],al //3.3 Indexed Addressing//indexed register:si di -offer offsetmov [si],dxadd ax,[di]mov [si+0x100],al//3.4 Base Indexed Addressingadd word [bx+di],0x3000 Manipulate disk to read data1234567891011121314151617181920//CPU accesses disk by manipulate I/O ports that are addressed independent to memory address. A I/O port actually is a 8-bit or 16-bit register.//All ports are unified addressing, from 0x0001 to 0xffff. Every I/O interface is assigned some ports. //0x1f0-0x1f7 are assigned master hard disk interface//while slave hard disk with 0x170-0x177//0x1f0: data port//0x1f1: fault information port//0x1f2: indicate how many sectors to read//0x1f3-0x1f6: save 24-bit LBA address,the high four bits of 0x1f6 have extra meaning,which don't indicate location.//0x1f6: the seveth and the fifths bit are 1. The sixth bit: 0 CHS 1 LBA//the fourth bit: 0 master disk 1 slave disk//0x1f7: command and situation port. 0x20 is reading command.//About 0x1f7: the seveth bit means whether busy,the third bit means whether to be ready to exchange with cpu. CPU can read this port frequently, if it is 0x08 , that means hard disk gets ready to exchange data with cpu. While if it's the highest bit is 1, it can't transfer data.//Instruction format: in out :dx save port number , ax or al save datain al,dxin ax,dxout dx,alout dx,axout 0x37,al //;this is possible but impossible in in Control cursor by modifying ports in video card123456789101112131415//Since video card have many ports, we don't manipulate port as I/O interface, which means we dont write target port number into dx to point out which to operate. Pointing out target register by index register-0x3d4. While cursor position is kept in port 0x0e and 0x0f.//0x0e: high 8 bit , 0x0f: low 8 bit. data port: 0x3d5;get position of current cursormov dx,0x3d4mov al,0x0eout dx,almov dx,0x3d5in al,dxmov ah,almov dx,0x3d4mov al,0x0fout dx,almov dx,0x3d5in al,dx User program basic framework12345678910111213141516171819202122232425262728293031//when cpu jumps from loader to usr program, ds and es point out user program header segment basic addressSECTION header vstart=0 program_length: dd program_end code_entry: dw start dd section.code_1.start realloc_tb1_len: dw (header_end-code_1_segment)/4 code_1_segment: dd section.code_1.start code_2_segment: dd section.code_2.start data_1_segment: dd section.data_1.start data_2_segment: dd section.data_2.startheader_end:SECTION code_1 align=16 vstart=0 start: //this label is for jumping here easily //valid codes SECTION code_2 align=16 vstart=0 begin: //this label is for jump here easilySECTION data_1 align=16 vstart=0 SECTION data_2 align=16 vstart=0 SECTION stack align=16 vstart=0 resb 256 //declare stack space, can changestack_end: //this label is put into sp.SECTION trail align=16program_end: //this label is for caculating program length. BCD code (Binary coded Decimal)123For a decimal number 25, its normal binary format is 00011001but the BCD format changes 2 and 5 to binary respectively, which is 00100101.Obviously, four bit represent up to 15, but decimal up to 9, so more than 1001 impossible Interrupt1234567891011121314151: Interrupt is sent into CPU with two leads which are NMI(NOn Maskable Interrupt, NMI) and INTR(Maskable Interrupt)2:8259 programmable Interrupt Controller (PIC) can be set sitation and interrupt number in every lead. There are two chips in every PC.3:8259 contains Interrupt Mask Register(IMR), a 8-bit register which corresponds eight leads, deciding whether the interrupt is vaild, 0: INTR avalible 1: INTR unavabilableMaster port: 0x20 0x21 Slave port: 0xa0 0xa1 Example: read IMR from in 0xa1 in slavein al,0xa1 // read before writeand al,0xfe // lead 0 allows interrupt from RTCout 0xa1,al //underlying information:0xa1 saves IMR4:Lead IR0 has the highest priority, while Lead IR7 has the lowest priority. Every lead has a Interrpt number which is programmable by the whole chip.5:8259 controller has a Interrupt Service Register(ISR), 8 bit, its every bit correspond to an interrupt lead. When processing interrupt, 8259 will set corresponding bit 1 indicating doing serevice for the interrupt from this lead IVT(Interrupt Vector Table)12IVT is put within 00000-003ff, including up to 256 interrupt service program,After 8256 sends interrupt number to CPU, CPU will get the entry of interrupt service programm according to interrupt number. CMOS RAM inside RTC(Real-Time Clock)12345670x70 , 0x74 indexed port0x71 , 0x75 data portExample: obtain weekmov al,0x06 ; the 0x06 byte keeps what weekout 0x70,alin al,0x71 8086 Memory Layout1234567891011121: 0x00000 ~ 0x003ff :Interrupt vector table 1024B2: 0x00400 ~ 0x004ff :BIOS data area 256B3: 0x00500 ~ 0x07bff :Free area 1280B4: 0x07c00 ~ 0x07dff :Boot sector entry 512B5: 0x07e00 ~ 0x9ffff :Free area 32256B6: 0xa0000 ~ 0xaffff :Graph and video buffer 64KB7: 0xb0000 ~ 0xb7fff :mono text video buffer 32KB8: 0xb8000 ~ 0xbffff :chroma text video buffer 32KB9: 0xc0000 ~ 0xc7fff :video card bios 32KB10: 0xc8000 ~ 0xcbfff :IDE controller BISO 16KB11: 0xcc000 ~ 0xeffff 143KB12: 0xf0000 ~ 0xfffff :system BIOS 64KBs Real mode into Protect mode reference code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778SECTION mbr align=16 vstart=0x7c00 [bits 16] mov ax,cs mov ss,ax mov sp,0x7c00 mov ax,[cs:gdt_base] mov dx,[cs:gdt_base+0x02] mov bx,16 div bx mov ds,ax mov bx,dx mov dword [bx],0x00000000 mov dword [bx+0x04],0x00000000 mov dword [bx+0x08],0x7c0001ff mov dword [bx+0x0c],0x00409800 mov dword [bx+0x10],0x8000ffff mov dword [bx+0x14],0x0040920b mov dword [bx+0x18],0x00007a00 mov dword [bx+0x1c],0x00409600 mov word [cs:gdt_size],31 lgdt [cs:gdt_size] ;load gdt register 48 bit ;connect A20 in al,0x92 or al,0000_0010B out 0x92,al cli mov eax,cr0 or eax,1 mov cr0,eax jmp dword 0x0008:flush-0x7c00 [bits 32] flush: mov cx,00000000000_10_000B mov ds,cx mov byte [0x00],'P' mov byte [0x02],'r' mov byte [0x04],'o' mov byte [0x06],'t' mov byte [0x08],'e' mov byte [0x0a],'c' mov byte [0x0c],'t' mov byte [0x0e],'m' mov byte [0x10],'o' mov byte [0x12],'d' mov byte [0x14],'e' mov byte [0x16],' ' mov byte [0x18],'O' mov byte [0x1a],'K' mov cx,00000000000_11_000B mov ss,cx mov esp,0x7c00 mov ebp,esp push byte '.' sub ebp,4 cmp ebp,esp jnz ghalt pop eax mov [0x1c],al ghalt: hlt gdt_size: dw 0 gdt_base: dd 0x00007e00 times 510-($-$$) db 0 db 0x55,0xaa Macro*1234567891011121314151: define a Macro%macro Descriptor 3 ; 3 is 3 parameter number dw %2 &amp; 0ffffh dw %1 &amp; 0ffffh db (%1 &gt;&gt; 16) &amp; 0ffh dw ((%2 &gt;&gt; 8) &amp; 0f00h) | (%3 &amp; 0f0ffh) db (%1 &gt;&gt; 24) &amp; 0ffh%endmacro2: use it in asm fileLABEL_GDT: Descriptor 0, 0 ,0Preprocessor will receive 3 parameters into macro definition and then substitute Descriptor for the macro code, which is there dw, dw, db, dw, db. CPL, DPL, RPL*12345CPL: Current Privilege Level saved in cs or ss. It may be equal to current segment descriptor privilege but may not. If one app shifts to another lower privilege app, CPL will change.DPL: Descriptor Privilege Level saved in segment descriptorRPL: Request Privilege Level saved in selector. Gate*12Calling a gate has two parts:from lower privilege to higher with call :from higher privilege to lower with ret CR 0-4*123456CR0: include flags to control CPU mode and system controlCR1: keptCR2: include liner address leading to page faultCR3: Page Directory Base address RegisterCR3 just has 20 bits page directory base address, which means page directory table will be 4-KB alignment as PDE and PTE be.","categories":[{"name":"Assembly language","slug":"Assembly-language","permalink":"http://yoursite.com/categories/Assembly-language/"}],"tags":[],"author":"Virux"},{"title":"C features","slug":"C features","date":"2021-04-20T06:35:01.000Z","updated":"2021-04-21T15:15:31.419Z","comments":true,"path":"2021/04/20/C features/","link":"","permalink":"http://yoursite.com/2021/04/20/C%20features/","excerpt":"","text":"1.const关键字在声明指针时不同位置形成的不同指针123const double *pc; //意味着不能通过该指针来修改其所指向的变量double * const pc; //意味着在初始化后，pc不能指向其他变量，但能通过该指针改变其指向的值const double * const pc; //同上 2.指针与多维数组的一个范例1zippo[2][1]==*(*(zippo+2)+1) //zippo视为一个指针 3.声明指针数组和指向多维数组的指针12int *pax[2];//数组pax中含有两个int类型的指针int (*pz)[2];//pz指针可以指向zippo[4][2]即pz=zippo 4.多维数组作函数形参1234//对于二维数组做函数形参，必须标明列数，行数是可选择性声明的，但compiler会忽略函数int sum(int ar[][4],int rows);int sum(int ar[3][4],int rows);//可编译通过，但是compiler会忽略行数3int sum4d(int ar[][12][20][30],int rows);//一般而言，声明多维数组只省略最左边的括号 5.复合字面量(compound literal)字面量是除符号常量外的常量。例如，5是int类型字面量，81.3是double类型的字面量，’Y’是char类型字面量。数组也有复合字面量。复合字面量是指提供临时需要的值的一种手段，复合字面量具有块作用域，这意味着一旦离开定义复合字面量的快，程序将无法保证该字面量是否存在。也就是说，复合字面量的定义在最内层的花括号中。 123456789(int[])&#123;50,20,90&#125;//内含3个元素的符合字面量int *pt1=(int[2])&#123;10,20&#125;;//复合字面量是匿名的，不能先创建然后再使用它，必须在创建的同时 使用它//还可以把复合字面量作为实际参数传递给带有匹配形式参数的函数int sum(const int ar[],int n);sum((int [])&#123;4,4,4,5,5,5&#125;,6);//结构的复合字面量(struct rect)&#123;10.5,20.0&#125;;//也可以进行取址操作&amp;(struct rect)&#123;10.5,20.0&#125; 6.结构变量允许相互赋值，但数组不允许12345//结构这样赋值是将captain的各个字段都变成和rightFiled中的各个字段相同的值//对captain的修改不影响rightFiledstruct names rightFiled=&#123;\"Ruthie\",\"George\"&#125;;struct names captain=rightFiled; // correctint a[5]=b; // false 7. 伸缩性数组成员(flexible array member)（C99）定义： 伸缩性数组必须是结构的最后一个成员； 结构中必须至少有一个成员； 伸缩数组的声明类似于普通数组，只是它的方括号中是空的 12345678struct flex&#123; int count; double average; double scores[]; //flexible array member&#125;;//注意具有伸缩性数组的结构体不能像普通结构体那样赋值struct flex *pf1,*pf2;*pf2=*pf1; // flase; 8.联合（Union）的初始化1234567891011//WARNING: Union can just only store one memeber,even it has enought space for other members ,it can't store two members at the same time.union hold&#123; int digit; double bigfl; char letter;&#125;;union hold=valA;ValA.letter='R';union hold valB=valA; //the first method;union hold valC=&#123;88&#125;; //initialize the 'digit' memberunion hold valD=&#123;.bigfl=118.2&#125; //disignate initializer 9.Anonymous Union and structure1234567891011121314151617// if declare a structure or union,which can contain anomymous union or structstruct carData&#123; char make[15]; int status; union&#123; struct owner owncar; struct leasecompany leasecar; &#125;; struct&#123; char first[20]; char last[20]; &#125;;&#125;//use . to access members of anonymous Union and structurestruct carData flits;flits.onwcar;flits.first; 10. Difference between #include&lt;&gt; and #include””&lt;&gt; :reference header files contained in library in complier “” :reference header files contained in programm relative directory 11. Difference between #define and type different with #define, typedef can just only create type symbol name,not value typedef is interpreted by complier , not preprocessor typedef is flexible than #define 12. #indef#ifndef 指令通常用于防止多次包含一个文件。也就是说，应该像下面这样设置头文件： 12345678/*things.h*/#ifndef THINGS_H_#define THINGS_H_........./*other content of this head file*/#endif 这样，在一些被显示包含的头文件中如果出现了隐式包含的头文件，就可以避免重复包含。同时，在标准库中，待测试的标识符（即上面的 THINGS_S_)具有如下规则：使用大写字母，用下划线字符代替文件名中的点字符，用下划线字符做前缀或后缀（可能使用两条下划线）。例如对于stdio.h，定义宏为： 1234#ifndef _STDIO_H#define _STDIO_H...#endif","categories":[{"name":"C","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[],"author":"Virux"}],"categories":[{"name":"C","slug":"C","permalink":"http://yoursite.com/categories/C/"},{"name":"computer hardware","slug":"computer-hardware","permalink":"http://yoursite.com/categories/computer-hardware/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"},{"name":"grammar","slug":"grammar","permalink":"http://yoursite.com/categories/grammar/"},{"name":"OSDev","slug":"OSDev","permalink":"http://yoursite.com/categories/OSDev/"},{"name":"Assembly language","slug":"Assembly-language","permalink":"http://yoursite.com/categories/Assembly-language/"}],"tags":[]}