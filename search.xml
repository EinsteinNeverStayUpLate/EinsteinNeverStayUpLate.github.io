<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>bus</title>
    <url>/2021/04/21/Bus/</url>
    <content><![CDATA[<p><img src="/2021/04/21/Bus/0.jpg" alt="0"></p>
<a id="more"></a>

<p>what is bus：</p>
<p>总线是连接各个部件的信息传输线，是各个部件共享的传输介质。</p>
<p>总线上信息传送：</p>
<p>​    串行，并行（需要多条数据线）</p>
<p>传输距离较长时不使用并行传输，一般用在机箱内。</p>
<p>总线结构的计算机举例：</p>
<p>1：单总线结构框图：总线会成为瓶颈</p>
<p><img src="/2021/04/21/Bus/C:%5CUsers%5C123%5CDesktop%5C%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.PNG" alt="单总线结构"></p>
<p>2：面向CPU的双总线结构</p>
<p><img src="/2021/04/21/Bus/C:%5CUsers%5C123%5CDesktop%5C%E5%8F%8C%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.PNG" alt="双总线结构"></p>
<p>DEFEAT：当主存要与外部设备，一定要经过CPU，会打断CPU的执行。</p>
<p>3：以存储器为中心</p>
<p><img src="/2021/04/21/Bus/C:%5CUsers%5C123%5CDesktop%5C%E9%9D%A2%E5%90%91%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%8F%8C%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.PNG" alt="面向存储器的双总线结构"></p>
<p>总线分类：（要有标准）</p>
<p>根据总线的位置进行划分：</p>
<p>1：片内总线： 芯片内部总线</p>
<p>2：系统总线： 计算机各部件之间的信息传输线</p>
<ul>
<li>数据总线  双向 与机器字长、存储字长有关</li>
<li>地址总线 单向   与存储地址、I/O地址有关,一般与MAR的长度相同</li>
<li>控制总线    有出 有入</li>
</ul>
<p>3：通信总线：用于计算机系统之间或计算机系统与其他系统（如控制仪表、移动通信等）之间的通信</p>
<p>传输方式：并行和串行</p>
<p>总线的特性及性能指标：</p>
<p>一：总线的物理实现</p>
<p>二：总线特性</p>
<ul>
<li>机械特性</li>
<li>电器特性  传输方向和有效的电平范围</li>
<li>功能特性  每根传输线的功能</li>
<li>时间特性  信号的时序关系</li>
</ul>
<p>总线的性能指标：</p>
<ul>
<li>总线的宽度 数据线的根数</li>
<li>标准传输率 每秒传输的最大字节数（MBps）</li>
<li>时钟同步/异步  同步、不同步</li>
<li>总线复用  地址线和数据线复用 （8086地址线和数据线复用）复用的是为了减少芯片的管角、脚数</li>
<li>信号线数  地址线 数据线和控制线的总和</li>
<li>总线控制方式  突发、自动、仲裁、逻辑、计数</li>
<li>其他指标   负载能力</li>
</ul>
<p>总线标准：</p>
<p>单总线结构</p>
<p>多总线结构</p>
<p><img src="/2021/04/21/Bus/C:%5CUsers%5C123%5CDesktop%5CPictures%5C%E5%A4%9A%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.PNG" alt="多总线结构"></p>
<p>通道：具有特殊功能的处理器，有自己的控制器，指令系统。通道的程序由操作系统来编写。</p>
<p>三总线结构</p>
<p><img src="/2021/04/21/Bus/C:%5CUsers%5C123%5CDesktop%5CPictures%5C%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.PNG" alt="三总线结构"></p>
<p>另一种三总线结构：</p>
<p><img src="/2021/04/21/Bus/C:%5CUsers%5C123%5CDesktop%5CPictures%5C%E5%8F%88%E4%B8%80%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.PNG" alt="又一三总线结构"></p>
<p>四总线结构</p>
<p>将低速设备和高速设备进行分类组织</p>
<p>总线结构举例：</p>
<p><strong>总线控制（重难点）</strong></p>
<p>一：总线判优控制</p>
<p>1.基本概念</p>
<ul>
<li><p>主设备（模块） 对总线由控制权</p>
</li>
<li><p>从设备（模块） 响应从主设备发来的总线命令</p>
</li>
<li><p>总线判优控制：</p>
<ul>
<li>集中式 ：链式查询，计数器定时查询，独立请求方式</li>
<li>分布式：</li>
</ul>
</li>
<li><p>链式查询：一般用于微型计算机和嵌入式系统</p>
<p>如果I/O接口有总线占用请求，通过BR向总线控制部件提出占用请求。</p>
<p>BG设备查询接口是否总线占用请求。</p>
<p>某个获得授权的接口通过BS总线设置总线忙，然后就获得总线的使用权。</p>
<p>如果BG发送的信号经过某个故障接口时无法传下去，则后续的接口无法查询得到。</p>
</li>
<li><p>计数器定时查询</p>
<p>设备地址上传输的是一个计数器给出的。通过的设备查找某个设备是否提出了总线占用请求。</p>
<p>总线控制部件中有一个计数器。</p>
<p>计数器在总线允许被占用的情况下启动。</p>
<p>优点：优先级的确定十分灵活，可通过软件的方式控制计数器</p>
</li>
<li><p>独立请求方式</p>
<p>每个接口都有BG 和BR两条线，总线控制部件内部有一个排队器。这样优先级的设定十分灵活</p>
<p>接口BR发送总线占用请求信号到总线控制器。</p>
<p>控制部件会对所有请求总线的接口中的某一个应答。获得应答的设备便占有总线的使用权。</p>
</li>
</ul>
<p>二：总线的通信控制</p>
<p>目的： 解决通信双方的 <strong>协调配合</strong> 问题</p>
]]></content>
      <categories>
        <category>computer hardware</category>
      </categories>
  </entry>
  <entry>
    <title>Bochs usage</title>
    <url>/2021/04/21/Bochs%20usage/</url>
    <content><![CDATA[<p><img src="/2021/04/21/Bochs%20usage/0.jpg" alt="0"></p>
<a id="more"></a>

<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>​    Bochs is a virtual machine, which is kind of different from other virtual machine software, like VirtualBox and VMware. The most distinctive point is that it can debug kernel codes. So, its  usage may not friendly. Before using it to virtualize physical machine, it need configuring a configure file, which contains many parameters you want to emulate.</p>
<h3 id="Downloading-website"><a href="#Downloading-website" class="headerlink" title="Downloading website"></a>Downloading website</h3><p><a href="http://bochs.sourceforge.net/" target="_blank" rel="noopener">http://bochs.sourceforge.net/</a></p>
<p><strong>NOTE: dlxlinux, demo of usage , of version 2.6.11 can’t be successfully run.</strong></p>
<h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p>​    Using Bochs to debug, two files are inevitable and should be generated manually, configure file and image file.<br>​    For config file, the following is an example. Each parameter’s meaning can be looked up from bochsrc-smaple.txt in Bochs directory.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># how much memory the emulated machine will have</span></span><br><span class="line">megs: <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># filename of ROM images</span></span><br><span class="line">romimage: file=../BIOS-bochs-latest</span><br><span class="line">vgaromimage: file=../VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line"># what disk images will be used </span><br><span class="line">floppya: <span class="number">1</span>_44=floppya.img, status=inserted</span><br><span class="line">floppyb: <span class="number">1</span>_44=floppyb.img, status=inserted</span><br><span class="line"></span><br><span class="line"># hard disk</span><br><span class="line">ata0: enabled=<span class="number">1</span>, ioaddr1=<span class="number">0x1f0</span>, ioaddr2=<span class="number">0x3f0</span>, irq=<span class="number">14</span></span><br><span class="line">ata0-master: type=disk, path=<span class="string">"a.img"</span>, cylinders=<span class="number">306</span>, heads=<span class="number">4</span>, spt=<span class="number">17</span></span><br><span class="line"></span><br><span class="line"># choose the boot disk.</span><br><span class="line">boot: c</span><br><span class="line"></span><br><span class="line"># <span class="keyword">default</span> <span class="built_in">config</span> interface is textconfig.</span><br><span class="line">#config_interface: textconfig</span><br><span class="line">#config_interface: wx</span><br><span class="line"></span><br><span class="line">#display_library: x</span><br><span class="line"># other choices: win32 sdl wx carbon amigaos beos macintosh nogui rfb term svga</span><br><span class="line"></span><br><span class="line"># where <span class="keyword">do</span> we send <span class="built_in">log</span> messages?</span><br><span class="line"><span class="built_in">log</span>: bochsout.txt</span><br><span class="line"></span><br><span class="line"># disable the mouse, since DLX is <span class="built_in">text</span> only</span><br><span class="line">mouse: enabled=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"># <span class="built_in">set</span> up IPS value <span class="keyword">and</span> clock sync</span><br><span class="line">cpu: ips=<span class="number">15000000</span></span><br><span class="line">clock: sync=both</span><br><span class="line">    </span><br><span class="line">keyboard: keymap=../keymaps/x11-pc-us.<span class="built_in">map</span></span><br><span class="line">#keyboard: keymap=../keymaps/x11-pc-fr.<span class="built_in">map</span></span><br><span class="line">#keyboard: keymap=../keymaps/x11-pc-de.<span class="built_in">map</span></span><br><span class="line">#keyboard: keymap=../keymaps/x11-pc-es.<span class="built_in">map</span></span><br></pre></td></tr></table></figure>

<p>​    For image file, it could be floppy, hard disk and CDROM, all of which should be written with binary file which can appear with NASM compiling .asm file to .bin file.<br>​    To utilize debug function, open <strong>bochsdbg.exe</strong>.</p>
]]></content>
      <categories>
        <category>OSDev</category>
      </categories>
  </entry>
  <entry>
    <title>C head file contents</title>
    <url>/2021/04/21/C%20head%20file%20contents/</url>
    <content><![CDATA[<p><img src="/2021/04/21/C%20head%20file%20contents/1.jpg" alt="1"></p>
<a id="more"></a>

<ul>
<li><p><strong>明示常量</strong>——例如，stdio.h中定义的EOF，NULL和BUFSIZE（标准I/O缓冲区大小）</p>
</li>
<li><p><strong>宏函数</strong>——例如，getc(stdin) 通常用getchar()定义，而getc()经常用于定义较复杂的宏，头文件ctype.h通常包含ctype系列函数的宏定义</p>
</li>
<li><p><strong>函数声明</strong>——例如，在string.h头文件包含字符串函数系列的函数声明。在ANSI C和后面的标准中，函数声明都是函数原型形式。</p>
</li>
<li><p><strong>结构模板定义</strong>——标准I/O函数使用FILE结构，该结构中包含了文件和与文件缓冲区相关的信息。FILE结构在头文件stdio.h中。</p>
</li>
<li><p><strong>类型定义</strong>——标准I/O函数使用指向FILE的指针作为参数。通常，stdio.h用#define或typedef把FIEL定义为指向结构的指针。类似地，size_t和time_t类型也定义在头文件中。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>C features</title>
    <url>/2021/04/20/C%20features/</url>
    <content><![CDATA[<p><img src="/2021/04/20/C%20features/1.png" alt="1"></p>
<a id="more"></a>

<h4 id="1-const关键字在声明指针时不同位置形成的不同指针"><a href="#1-const关键字在声明指针时不同位置形成的不同指针" class="headerlink" title="1.const关键字在声明指针时不同位置形成的不同指针"></a>1.const关键字在声明指针时不同位置形成的不同指针</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *pc;  <span class="comment">//意味着不能通过该指针来修改其所指向的变量</span></span><br><span class="line"><span class="keyword">double</span> * <span class="keyword">const</span> pc; <span class="comment">//意味着在初始化后，pc不能指向其他变量，但能通过该指针改变其指向的值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> * <span class="keyword">const</span> pc; <span class="comment">//同上</span></span><br></pre></td></tr></table></figure>

<h4 id="2-指针与多维数组的一个范例"><a href="#2-指针与多维数组的一个范例" class="headerlink" title="2.指针与多维数组的一个范例"></a>2.指针与多维数组的一个范例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">zippo[<span class="number">2</span>][<span class="number">1</span>]==*(*(zippo+<span class="number">2</span>)+<span class="number">1</span>) <span class="comment">//zippo视为一个指针</span></span><br></pre></td></tr></table></figure>

<h4 id="3-声明指针数组和指向多维数组的指针"><a href="#3-声明指针数组和指向多维数组的指针" class="headerlink" title="3.声明指针数组和指向多维数组的指针"></a>3.声明指针数组和指向多维数组的指针</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pax[<span class="number">2</span>];<span class="comment">//数组pax中含有两个int类型的指针</span></span><br><span class="line"><span class="keyword">int</span> (*pz)[<span class="number">2</span>];<span class="comment">//pz指针可以指向zippo[4][2]即pz=zippo</span></span><br></pre></td></tr></table></figure>

<h4 id="4-多维数组作函数形参"><a href="#4-多维数组作函数形参" class="headerlink" title="4.多维数组作函数形参"></a>4.多维数组作函数形参</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于二维数组做函数形参，必须标明列数，行数是可选择性声明的，但compiler会忽略函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> ar[][<span class="number">4</span>],<span class="keyword">int</span> rows)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> ar[<span class="number">3</span>][<span class="number">4</span>],<span class="keyword">int</span> rows)</span></span>;<span class="comment">//可编译通过，但是compiler会忽略行数3</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum4d</span><span class="params">(<span class="keyword">int</span> ar[][<span class="number">12</span>][<span class="number">20</span>][<span class="number">30</span>],<span class="keyword">int</span> rows)</span></span>;<span class="comment">//一般而言，声明多维数组只省略最左边的括号</span></span><br></pre></td></tr></table></figure>

<h4 id="5-复合字面量-compound-literal"><a href="#5-复合字面量-compound-literal" class="headerlink" title="5.复合字面量(compound literal)"></a>5.复合字面量(compound literal)</h4><p>字面量是除符号常量外的常量。例如，5是int类型字面量，81.3是double类型的字面量，’Y’是char类型字面量。数组也有复合字面量。复合字面量是指提供临时需要的值的一种手段，复合字面量具有块作用域，这意味着一旦离开定义复合字面量的快，程序将无法保证该字面量是否存在。也就是说，复合字面量的定义在最内层的花括号中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">int</span>[])&#123;<span class="number">50</span>,<span class="number">20</span>,<span class="number">90</span>&#125;<span class="comment">//内含3个元素的符合字面量</span></span><br><span class="line"><span class="keyword">int</span> *pt1=(<span class="keyword">int</span>[<span class="number">2</span>])&#123;<span class="number">10</span>,<span class="number">20</span>&#125;;<span class="comment">//复合字面量是匿名的，不能先创建然后再使用它，必须在创建的同时						  使用它</span></span><br><span class="line"><span class="comment">//还可以把复合字面量作为实际参数传递给带有匹配形式参数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ar[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">sum((<span class="keyword">int</span> [])&#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>&#125;,<span class="number">6</span>);</span><br><span class="line"><span class="comment">//结构的复合字面量</span></span><br><span class="line">(struct <span class="built_in">rect</span>)&#123;<span class="number">10.5</span>,<span class="number">20.0</span>&#125;;</span><br><span class="line"><span class="comment">//也可以进行取址操作</span></span><br><span class="line">&amp;(struct <span class="built_in">rect</span>)&#123;<span class="number">10.5</span>,<span class="number">20.0</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-结构变量允许相互赋值，但数组不允许"><a href="#6-结构变量允许相互赋值，但数组不允许" class="headerlink" title="6.结构变量允许相互赋值，但数组不允许"></a>6.结构变量允许相互赋值，但数组不允许</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构这样赋值是将captain的各个字段都变成和rightFiled中的各个字段相同的值</span></span><br><span class="line"><span class="comment">//对captain的修改不影响rightFiled</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">rightFiled</span>=&#123;</span><span class="string">"Ruthie"</span>,<span class="string">"George"</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">captain</span>=<span class="title">rightFiled</span>;</span> <span class="comment">// correct</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>]=b;  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="7-伸缩性数组成员-flexible-array-member-（C99）"><a href="#7-伸缩性数组成员-flexible-array-member-（C99）" class="headerlink" title="7. 伸缩性数组成员(flexible array member)（C99）"></a>7. 伸缩性数组成员(flexible array member)（C99）</h4><p>定义：</p>
<ul>
<li>伸缩性数组必须是结构的最后一个成员；</li>
<li>结构中必须至少有一个成员；</li>
<li>伸缩数组的声明类似于普通数组，只是它的方括号中是空的</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flex</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">double</span> average;</span><br><span class="line">    <span class="keyword">double</span> scores[]; <span class="comment">//flexible array member</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//注意具有伸缩性数组的结构体不能像普通结构体那样赋值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flex</span> *<span class="title">pf1</span>,*<span class="title">pf2</span>;</span></span><br><span class="line">*pf2=*pf1; <span class="comment">// flase;</span></span><br></pre></td></tr></table></figure>

<h4 id="8-联合（Union）的初始化"><a href="#8-联合（Union）的初始化" class="headerlink" title="8.联合（Union）的初始化"></a>8.联合（Union）的初始化</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//WARNING: Union can just only store one memeber,even it has enought space for other members ,it can't store two members at the same time.</span></span><br><span class="line"><span class="keyword">union</span> hold&#123;</span><br><span class="line">    <span class="keyword">int</span> digit;</span><br><span class="line">    <span class="keyword">double</span> bigfl;</span><br><span class="line">    <span class="keyword">char</span> letter;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> hold=valA;</span><br><span class="line">ValA.letter=<span class="string">'R'</span>;</span><br><span class="line"><span class="keyword">union</span> hold valB=valA; <span class="comment">//the first method;</span></span><br><span class="line"><span class="keyword">union</span> hold valC=&#123;<span class="number">88</span>&#125;; <span class="comment">//initialize the 'digit' member</span></span><br><span class="line"><span class="keyword">union</span> hold valD=&#123;.bigfl=<span class="number">118.2</span>&#125; <span class="comment">//disignate initializer</span></span><br></pre></td></tr></table></figure>

<h4 id="9-Anonymous-Union-and-structure"><a href="#9-Anonymous-Union-and-structure" class="headerlink" title="9.Anonymous Union and structure"></a>9.Anonymous Union and structure</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if declare a structure or union,which can contain anomymous union or struct</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">carData</span>&#123;</span></span><br><span class="line">   <span class="keyword">char</span> make[<span class="number">15</span>];</span><br><span class="line">   <span class="keyword">int</span> status;</span><br><span class="line">   <span class="keyword">union</span>&#123;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">owner</span> <span class="title">owncar</span>;</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">leasecompany</span> <span class="title">leasecar</span>;</span></span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">       <span class="keyword">char</span> first[<span class="number">20</span>];</span><br><span class="line">       <span class="keyword">char</span> last[<span class="number">20</span>];</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//use . to access members of anonymous Union and structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">carData</span> <span class="title">flits</span>;</span></span><br><span class="line">flits.onwcar;</span><br><span class="line">flits.first;</span><br></pre></td></tr></table></figure>

<h4 id="10-Difference-between-include-lt-gt-and-include””"><a href="#10-Difference-between-include-lt-gt-and-include””" class="headerlink" title="10. Difference between #include&lt;&gt; and #include””"></a>10. Difference between #include&lt;&gt; and #include””</h4><p>&lt;&gt; :reference header files contained in library in complier</p>
<p>“”  :reference header files contained in programm relative directory</p>
<h4 id="11-Difference-between-define-and-type"><a href="#11-Difference-between-define-and-type" class="headerlink" title="11. Difference between #define and type"></a>11. Difference between #define and type</h4><ul>
<li>different with <strong>#define</strong>, <strong>typedef</strong> can just only create type symbol name,not value</li>
<li><strong>typedef</strong> is interpreted by complier , not preprocessor</li>
<li><strong>typedef</strong> is flexible than <strong>#define</strong></li>
</ul>
<h3 id="12-indef"><a href="#12-indef" class="headerlink" title="12. #indef"></a>12. #indef</h3><p>#ifndef 指令通常用于防止多次包含一个文件。也就是说，应该像下面这样设置头文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*things.h*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THINGS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THINGS_H_</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*other content of this head file*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这样，在一些被显示包含的头文件中如果出现了隐式包含的头文件，就可以避免重复包含。同时，在标准库中，待测试的标识符（即上面的 THINGS_S_)具有如下规则：使用大写字母，用下划线字符代替文件名中的点字符，用下划线字符做前缀或后缀（可能使用两条下划线）。<br>例如对于stdio.h，定义宏为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _STDIO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _STDIO_H</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>English grammar</title>
    <url>/2021/04/21/English%20grammar/</url>
    <content><![CDATA[<p><img src="/2021/04/21/English%20grammar/1.jpg" alt="1"></p>
<p>Common English grammar structures.</p>
<a id="more"></a>



<h3 id="needn’t-have-done-and-could-have-done"><a href="#needn’t-have-done-and-could-have-done" class="headerlink" title="needn’t have done and could have done"></a>needn’t have done and could have done</h3><ul>
<li>needn’t have done:  I needn’t have (done)  something  = I <strong>did</strong> something but now I know that it was not necessary.</li>
<li>could have done:  Most often, we use *<em>could have (done) *</em> for things which were possible but did not happen.</li>
</ul>
<p><strong><em>Example</em></strong></p>
<p>I got up very early because I had to get ready to go away. But in fact it didn’t take me long to get ready. So, I <strong>needn’t have got up</strong> so early. I *<em>could have stayed *</em> in bed longer.</p>
<hr>
<h3 id="modals-have-done"><a href="#modals-have-done" class="headerlink" title="modals + have done"></a>modals + have done</h3><h4 id="could-not-have-done"><a href="#could-not-have-done" class="headerlink" title="could (not) have done"></a>could (not) have done</h4><p>Most often, we use could have (done)  for things which were possible <strong>but did not happen</strong></p>
<ul>
<li>Why did you stay at a hotel when you went to New York?You <strong>could have stayed</strong> with Barbara.</li>
</ul>
<hr>
<h4 id="may-have-done-and-might-have-done"><a href="#may-have-done-and-might-have-done" class="headerlink" title="may have done and might have done"></a>may have done and might have done</h4><p>Both of them  just express a possibility (whatever positive or negative)</p>
<ul>
<li>A: I wonder why Kay didn’t answer the phone.</li>
<li>B: She may have been asleep.</li>
</ul>
<ul>
<li>A: I was surprised that Sarah wasn’t at the meeting.</li>
<li>B: She might not have known about it.</li>
</ul>
<p><strong><em>NOTE:</em></strong>  couldn’t (negative) is different from <strong>may not</strong> and <strong>might not</strong></p>
<ul>
<li>She was too far away, so she couldn’t have seen you.(=it is not possible that she saw you)</li>
</ul>
<ul>
<li>A: I wonder why she didn’t say hello.</li>
<li>B: She might not have seen you.</li>
</ul>
<hr>
<h4 id="needn’t-have-done"><a href="#needn’t-have-done" class="headerlink" title="needn’t have done"></a>needn’t have done</h4><p>It means you really did something but now you know it was not necessary. So, you really did.<br>But ,comparing to <strong>could have done</strong> ,which means you didn’t do something that could happen probably  , this sentence is opposite to <strong>could have done</strong>. (in a sense).</p>
<ul>
<li>I got up very early because  I had to get ready to go away. But in fact it didn’t take me long to get ready. So, I *<em>needn’t have got up *</em> so early. I *<em>could have stayed *</em> in bed  longer.</li>
</ul>
<hr>
<h4 id="should-not-have-done"><a href="#should-not-have-done" class="headerlink" title="should (not) have done"></a>should (not) have done</h4><p>You didn’t do it but it would have been the right thing to do. (for positive)</p>
<ul>
<li>(positive): It was a great party last night. You *<em>should have *</em> come. Why didn’t you?</li>
<li>(negative): I’m feeling sick. I *<em>shouldn’t have eaten *</em> so much chocolate.</li>
</ul>
<hr>
<h3 id="may-and-might"><a href="#may-and-might" class="headerlink" title="may and might"></a>may and might</h3><p>We use <strong>may</strong> or <strong>might</strong> to say that something is a possibility. Usually you can use <strong>may</strong> or <strong>might</strong><br>you can say:</p>
<ul>
<li>It <strong>may</strong> be true . or It <strong>might</strong> be true.</li>
<li>She <strong>might</strong> know. or She <strong>might</strong> know.</li>
</ul>
<p>Sometimes <strong>could</strong> has a similar meaning to <strong>may</strong> and  <strong>might</strong><br>But <strong>couldn’t</strong> is different from <strong>may not ** and **might not</strong>.</p>
<ul>
<li><p>She was too far away, so she couldn’t have seen you .</p>
</li>
<li><p>A:I wonder why she didn’t say hello.</p>
<p>She might not have seen you.</p>
</li>
</ul>
<p>But we use only <strong>might</strong> (not may) when the situation is <strong>not real</strong>.</p>
<ul>
<li><p>If I knew them better, I might invite them to dinner.</p>
<p>(The situation here is not real because I don’t know them very well,so I’m not going to invite them.’May’ is not possible in this example)</p>
<h3 id="Might-as-well-may-as-well"><a href="#Might-as-well-may-as-well" class="headerlink" title="Might as well / may as well"></a>Might as well / may as well</h3></li>
<li><p>What shall we do?Shall we walk?</p>
</li>
<li><p>We might as well. It’s a nice day and I don’t want to wait here for an hour.</p>
</li>
</ul>
<p>‘(We) might as well do something’ =(We) should do something because  there is nothing better to do and there is no reason not to do it. You can also say ‘may as well (do)’.</p>
<ul>
<li>A: What time  are you going?</li>
<li>Well , I’m ready, so I might as well go now.</li>
</ul>
<hr>
<h3 id="difference-between-will-and-going-to"><a href="#difference-between-will-and-going-to" class="headerlink" title="difference between will and going to"></a>difference between will and going to</h3><p><strong>wil</strong>l: We use  <strong>will</strong> when we decide to do something at the time of speaking. The speaker has not decided before. The party is a new idea.</p>
<p>For example:</p>
<p>SUE: Let’s have a party.</p>
<p>HELEN: That’s a great idea. We<strong>‘ll</strong> invite lots of people.</p>
<hr>
<p><strong>going to</strong>: We use <strong>going to</strong> when we have already decided to do something. Helen had already decided to invite lots of people before she spoke to Dave.</p>
<p>For example:</p>
<p>HELEN: Sue and I have decide to have a party.   We<strong>‘re going to</strong> invite lots of people.</p>
<hr>
<h3 id="could-and-was-were-able-to"><a href="#could-and-was-were-able-to" class="headerlink" title="could and was/were able to"></a>could and was/were able to</h3><p>We use <strong>could</strong> to say that somebody had the general ability or permission to do something:</p>
<ul>
<li>My grandfather could speak five languages.</li>
<li>We were completely free. We could do what we wanted.</li>
</ul>
<hr>
<p>We use <strong>could</strong> for general ability. But if we are talking about what happened in a particular situation , we use was/were able to… or managed to…(not <strong>could</strong>):</p>
<ul>
<li>The fire spread through the building quickly but everybody was able to escape.<br>or…everybody managed to escape.</li>
<li>They didn’t want to come with us at first but we managed to persuade them.<br>or…we were able to persuade them.(but not ‘could persuade’)</li>
</ul>
<hr>
<p><strong>Compare:</strong></p>
<ul>
<li>Jack was an excellent tennis players. He <strong>could beat</strong> anybody. (=he had the general ability to beat anybody)</li>
</ul>
<p><strong>but</strong></p>
<ul>
<li>Jack and Alf had a game of tennis yesterday. Alf played very well but in the end Jack managed to beat him. or…was able to beat him. (=he managed to beat him in this particular game)</li>
</ul>
<hr>
<h3 id="could-and-could-have"><a href="#could-and-could-have" class="headerlink" title="could and could have"></a>could and could have</h3><p>could:**</p>
<ul>
<li>use <strong>could</strong> to talk about possible actions now or in the future (especially to make a suggestion):<br>A: What shall we do this evening? B: We could go to cinema.<br>It’s a nice day. We could go for a walk.</li>
<li>You must use could(not ‘can’) when you don’t really mean what you say:<br>I’m so angry with him. I could kill him!(not ‘I can kill him’)</li>
<li>We also use could to say that something is possible now or in the future:<br>The phone is ringing. It could be Tim.(<strong>now</strong>)<br>I don’t know when they ‘ll be here . They could arrive at any time.(<strong>future</strong>)</li>
</ul>
<hr>
<p><strong>could have (done)</strong></p>
<p>Most often, we use <strong>could have (done)</strong> for things which were possible but did not happen:</p>
<ul>
<li>Why did you stay at a hotel when you went  to New York? You could have stayed with Barbara. (=you had the opportunity to stay with her but you didn’t)</li>
<li>Jack fell off a ladder yesterday but he’s all right. He’s lucky - he could hurt himself badly. (but he didn’t hurt himself)</li>
<li>Jack wanted Ken to lend him 50 last week.<br>Ken couldn’t have lent him 50. (because he was short of money)</li>
</ul>
<hr>
<h3 id="as"><a href="#as" class="headerlink" title="as"></a>as</h3><ol>
<li>as…as</li>
</ol>
<p>Any sentences using the structure <strong>as…as</strong> can rewrite a sentence with <strong>than</strong>. And the meaning doesn’t change.</p>
<ul>
<li>The city center wasn’t as crowded this morning as it usually is. (subject + verb after the second as)</li>
<li>I don’t know as many people as you do. (<strong>between the first and the second as ,it’s many+ noun, usually it should be a adj or adv, many/much+ noun can be an exception.</strong>)</li>
</ul>
<p><em>Note: It’s not necessary that after the second as , it must be subject +verb. Such as:</em></p>
<ul>
<li>Let’s walk. It’s just as quick as taking the bus.</li>
</ul>
<p>as soon as possible is common:</p>
<ul>
<li>Can you send me the money as soon as possible, please? (<strong>Usually, it’s put in the end of sentence).</strong></li>
</ul>
<hr>
<ol start="2">
<li>Another form: twice as…as , three times as…as etc:</li>
</ol>
<ul>
<li>Petrol is twice as expensive as it was a few years age.</li>
<li>Their house is about three times as big as ours. </li>
</ul>
<hr>
<ol start="3">
<li><strong>the same as</strong> is usual, but remember, between ‘same’ and ‘as’, it should be noun.</li>
</ol>
<ul>
<li>Ann’s salary is the same as mine.          or           Ann gets the same salary as me.</li>
<li>Tom is the same age as George.</li>
<li>‘What would you like to drink?’      ‘I’ll have the same as you.’</li>
</ul>
<hr>
<ol start="4">
<li>As (reason and time), here ‘as ‘ is a conjunction</li>
</ol>
<ul>
<li><p>As (reason): As sometimes means ‘because’:</p>
<ul>
<li>As it was a public holiday, all the shops were shut. (=because it was a public holiday)</li>
<li>As the live near us, we see them quite often.</li>
<li>We watched television all evening as we had nothing better to do.</li>
</ul>
</li>
<li><p>As(time):  more complicated than above.</p>
<ul>
<li>you can say that something happened as you were doing something else (= in the middle of doing something else):<ul>
<li>Jill slipped as she was getting off the bus.</li>
<li>The thief was seen as he was climbing over the wall.</li>
</ul>
</li>
<li>Most often we use as when two short actions happen at the same time:<ul>
<li>George arrived as Sue left. (=he arrived and Sue left at the same time)</li>
<li>We all waved goodbye to Liz as she drove away in her car.</li>
</ul>
</li>
<li>But we also use as when two things happen together <strong>over at longer period of time</strong>:<ul>
<li>As the day went on, the weather got worse.</li>
<li>I began to enjoy the job more as I got used to it.</li>
</ul>
</li>
<li>You can also use just as (=exactly at that moment): <ul>
<li>Just as I sat down, the phone rang.</li>
<li>Just as we were going out, it started to ran.</li>
<li>I had to leave just as the conversation was getting interesting.</li>
</ul>
</li>
</ul>
<hr>
</li>
</ul>
<ol start="5">
<li>We use <strong>as(time)</strong> for actions and happenings. <strong>As</strong> + <strong><em>a situation</em></strong> (not an action) usually means ‘because’:</li>
</ol>
<ul>
<li>As we were asleep, we didn’t hear the doorbell. (=because we were asleep)</li>
<li>As I walked into the room, the phone started ringing. (at the same time)</li>
<li>As they live near me, I see them quite often. (=because they live near me)</li>
</ul>
<hr>
<ol start="6">
<li>Another use: We use <strong>as</strong> before a subject + verb:</li>
</ol>
<ul>
<li>I didn’t move anything. I left everything as I found it.</li>
<li>They did as they promised.</li>
</ul>
<p>We also say <strong>as you know/as I said/ as she expected/ as I thought etc:</strong></p>
<ul>
<li>As you know, it’s Tom’s birthday next week. (‘As part’ is put in the head)</li>
<li>Jane failed her driving test, as she expected.</li>
</ul>
<hr>
<ol start="7">
<li>Note that we say <strong>as usual / as always:</strong></li>
</ol>
<ul>
<li>You’re late as usual.</li>
</ul>
<hr>
<h3 id="as-long-as"><a href="#as-long-as" class="headerlink" title="as long as"></a>as long as</h3><p><strong>as long as</strong>  , <strong>so long as</strong> , <strong>provided</strong> , <strong>providing</strong></p>
<p>All these expressions mean <strong><em>‘if’</em></strong> or ‘on condition that’</p>
<ul>
<li>You can use my car <strong>as(so) long as</strong> you drive carefully.</li>
<li>Travelling by car is convenient <strong>provided (providing)</strong> you have somewhere to park.</li>
<li>*<em>Providing (Provided) *</em> she studies hard, she’ll pass her exams.</li>
</ul>
<p>When you are talking about the future, do not use <strong>will</strong> after unless / as long as / provided / providing.<br>Use a present tense.</p>
<hr>
<h3 id="in-case-of"><a href="#in-case-of" class="headerlink" title="in case (of)"></a>in case (of)</h3><p>Some examples of in case:</p>
<ul>
<li>Ann might phone tonight. I don’t want to go out in case she phones.</li>
<li>I’ll draw a map for you incase you can’t find our house.</li>
</ul>
<p>We use <strong>just in case</strong> for a smaller possibility:</p>
<ul>
<li>I don’t think it will rain but I’ll take an umbrella just in case.</li>
</ul>
<p>‘In case of…’ is not the same as ‘in case’. <strong>In case of</strong>=’if there is…’<strong><em>(especially in notices etc.):</em></strong></p>
<ul>
<li>In case of fire, please leave the building as quickly as possible.</li>
<li>In case of emergency, telephone this number.</li>
</ul>
<hr>
<h3 id="the…-the-…"><a href="#the…-the-…" class="headerlink" title="the… the …"></a>the… the …</h3><p>It’s comparison structure. We use it to say that one thing depends on another thing:</p>
<ul>
<li>The warmer the weather, the better I feel.</li>
<li>The sooner we leave, the sooner we will arrive.</li>
<li>The younger you are, the easier it is to learn.</li>
<li>The more expensive the hotel, the better the service.</li>
</ul>
<p><strong><em>Note:</em></strong>  本质来说，前后两个<strong>the</strong> 句子都是一个完整的正常语序的句子在进行倒装，同时由上述例子可以看出，will be /be  可以省略。</p>
<hr>
<h3 id="older-and-elder"><a href="#older-and-elder" class="headerlink" title="older and elder"></a>older and elder</h3><p>The comparative of old is older:</p>
<ul>
<li>Tom looks older than he really is.</li>
</ul>
<p>You can use elder(or older) when you talk about people in a family. You can say <strong>(my) elder brother/sister/son/daughter</strong>:</p>
<ul>
<li>My elder brother is a pilot.</li>
</ul>
<p>We say ‘my elder brother’ but we don’t say that ‘somebody is elder’:</p>
<ul>
<li>My brother is older than me(not ‘elder than me’)</li>
</ul>
]]></content>
      <categories>
        <category>grammar</category>
      </categories>
  </entry>
  <entry>
    <title>Hanming code</title>
    <url>/2021/04/21/Hanming%20Code/</url>
    <content><![CDATA[<p><img src="/2021/04/21/Hanming%20Code/0.jpg" alt="0"></p>
<a id="more"></a>

<p>简介：Richard Hanming与1950提出，它具有一位纠错能力。</p>
<p>编码纠错理论内容：</p>
<p>任何一种编码是否具有检测能力和纠错能力，都与编码的最小距离有关。所谓编码的最小距离，是指在一种编码系统中，任意两组合法代码之间的最少二进制位数的差异。<br>由纠错理论的</p>
<p>​                                                               L-1=D+C     且D&gt;=C</p>
<p>L表示最小距离，D（detection）检测错误的位数，C（correct）纠正错误的位数。<br>故通过加入检测位，可以有效提高检错能力和纠错能力。</p>
<hr>
<p>Hanming Code插入检测位过程：</p>
<p>假设欲传送的信息n位，则根据 2^k&gt;=n+k+1，可以得出所要加入检测位的位数k。k确定后，就要知道这k位的位置和信息（0或1）。k位检测为插入二进制串后，形成n+k为的一个二进制串，此时还没确定位置和信息，只知道有一个n+k位的二进制串。这里规定，这个二进制串从左到右进行位置编号，从1到n+k。<br>注意，Hanming Code一种非划分的分组检测方式，这意味着k位检测位需要承担各自小组的检测任务，这里的意思就是将n+k位的二进制串分成k组，但是组与组之间有重叠的。<br>接下来讨论k位检测码的插入位置。对于一个n+k位的二进制串，检测码在位置编号为2^(i-1)处，即1,2,4,8,16…都是检测位。（<strong>IT’s rule ，don’t ask why</strong>）<br>那么每一位检测码引领的组是哪些编号上的bit呢？<br>第2^(i-1)(i=1,2,3,4,…)位上的的检测位所引领的bit的位置编号具有以下特点：这个位置编号转化为二进制后，从右到左数，第 i 位是1。（<strong>位置和小组确定</strong>）<br>接下来讨论，检测位上是0还是1。<br>通常来说，我们假设对于每一个检测位和其所引领的小组会形成一个奇偶纠错系统。这意味着对于每一个小组，我们通过奇原则（1的个数为奇数）或偶原则（1的个数为偶数）去检测，能够发现这一个小组（包括检测位在内）是否在传送过程中发生了错误。（<strong>注意，一般而言我们认为一串二进制出错只出错一位，而不会出错两个位，这是一种概率超过百分之九十的事件</strong>）。<br>回到开头，我们如何确定检测位是0还是1？这里我们假设利用偶原则进行检验，则检测位Ci（i=1,2,4,8,16…)为</p>
<p>​                                 Ci=其所引领的小组内的所有bit（不包括Ci）进行连续异或所得到的的结果</p>
<hr>
<p>下面用一个例题概述上面过程，并给出接受方进行纠错的过程。</p>
<p>假设发送方欲发送信息0101，则经过Hanming 编码后，发送出去的信息是什么？</p>
<p>首先： C1 C2 0 C4 1 0 1 确认了位置。</p>
<p>C1=0⊕1⊕1=0  （第3,5,7位的bit）</p>
<p>C2=0⊕0⊕1=1 （第3,6,7位的bit）</p>
<p>C4=1⊕0⊕1=0（第5,6,7位的bit）</p>
<p>故最终传送出去的信息位：0100101</p>
<hr>
<p>假设接受方接到传送过来信息位：0110101，且双方已按偶原则编码，试问欲传送的信息是什么？</p>
<p>首先，这串信息不能直接拿来就用，要像纠错。纠错过程实际上是对传送后的Hanming code形成新的检测位Pi（i=1,2,4,8,16，…），本质是将每一小组拿出来单独进行奇偶校验。</p>
<p>P1=第一位⊕第三位⊕第五位⊕第七位=0⊕1⊕1⊕1=1</p>
<p>P2=第二位⊕第三位⊕第六位⊕第七位=1⊕1⊕0⊕1=1</p>
<p>P3=第四位⊕第五位⊕第六位⊕第七位=0⊕1⊕0⊕1=0</p>
<p>（<strong>这里注意，对于连续的⊕，如果其中有偶数个1，则所得结果必是0</strong>）</p>
<p>由上可知第一组，第二组出错了。则出错位那一位？<br>注意：我们上面已经说了，一般一位出错的概率最大。那么又因为第一，第二组出错，由此可知第一，第二组所共有的那一位（编号为3）出错。为什么不是编号为7的bit？因为假设编号为7出错，第三组也应该出错。所以将接收到的信息纠正为：0100101.</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>I/O interrupt processing procedure</title>
    <url>/2021/04/21/IO%20interrupt%20processing%20procedure/</url>
    <content><![CDATA[<p><img src="/2021/04/21/IO%20interrupt%20processing%20procedure/0.jpg" alt="0"></p>
<a id="more"></a>

<p>完整的操作过程如下：</p>
<p><img src="/2021/04/21/IO%20interrupt%20processing%20procedure/1.png" alt="1"></p>
<p>​    在执行主程序的过程中，会执行到一条输入指令。接着CPU将设备地址通过地址线送到接口电路中的设备选择电路，然后设备选择电路对该地址进行比较，看是否是该接口所连接的I/O设备，若是则该接口和相对应的设备就被选中，<strong>SEL</strong> 有效。只有SEL有效，接口电路才会开始工作。<br>​    CPU将命令送到接口中进行译码。由图可以看出<em>启动命令</em>和<em>SEL</em>同时有效才会是触发器D和触发器B被设置。触发器B被设置为1，而触发器D被设置为0。 表示设备开始工作，但同时数据并没有准备好。<strong>NOTE</strong>：触发器B的另一个作用是，启动I/O设备开始工作。<br>​    然后I/O设备开始工作，将data送入DBR中，并将触发器B和触发器D进行修改，B改为0而D改为1。接着，如果MASK触发器的非端为1（表示该中断并未被屏蔽），此时INTR就会经过两个1被置为1。<br>​    接着CPU在一条指令的执行阶段结束后，发出中断查询信号。 然后将INTR送入排队器排队，经过排队器排队后，排队器的输出信号只有一个是1，其他都是0。 排队器的输出信号输出到设备编码器，然后CPU发出中断响应信号（INTA）。之后，设备编码器就会形成向量地址，该地址经过数据线传给CPU，传给PC。PC利用改地址去取出中断服务程序的路口地址（无条件跳转）。然后就进入中断服务程序。</p>
<hr>
<p>中断服务程序的流程：</p>
<ul>
<li>保护现场：保护程序的断点（中断隐指令完成）；保存通用寄存器和状态寄存器。</li>
<li>中断服务：与I/O设备直接相关，不同功能设备的中断服务程序不同。</li>
<li>恢复现场：从主存或堆栈中恢复CPU寄存器中的内容。</li>
<li>中断返回：中断返回指令。</li>
</ul>
]]></content>
      <categories>
        <category>computer hardware</category>
      </categories>
  </entry>
  <entry>
    <title>MIPS addressing modes</title>
    <url>/2021/04/21/MIPS%20addressing%20modes/</url>
    <content><![CDATA[<p><img src="/2021/04/21/MIPS%20addressing%20modes/0.jpg" alt="0"></p>
<a id="more"></a> 

<h3 id="立即数寻址"><a href="#立即数寻址" class="headerlink" title="立即数寻址"></a>立即数寻址</h3><p>立即数寻址(immediate addressing)，操作数是位于指令自身的常数。</p>
<p><img src="/2021/04/21/MIPS%20addressing%20modes/1.png" alt="immediate addressing"></p>
<h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><p>寄存器寻址(register addressing)，操作数是寄存器。</p>
<p><img src="/2021/04/21/MIPS%20addressing%20modes/2.png" alt="register addressing"></p>
<h3 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h3><p>基址寻址(base addressing)或偏移寻址(displacement addressing)，操作数在内存中，其地址是指令中基址寄存器和常数的和。</p>
<p><img src="/2021/04/21/MIPS%20addressing%20modes/3.png" alt="displacement addressing"></p>
<h3 id="PC相对寻址"><a href="#PC相对寻址" class="headerlink" title="PC相对寻址"></a>PC相对寻址</h3><p>PC相对寻址(PC-relative addressing)，地址是PC和指令中常数的和。</p>
<p><img src="/2021/04/21/MIPS%20addressing%20modes/4.png" alt="PC-relative addressing"></p>
<h3 id="伪直接寻址"><a href="#伪直接寻址" class="headerlink" title="伪直接寻址"></a>伪直接寻址</h3><p>伪直接寻址(pseudodirect addressing)，跳转地址由指令中26位字段和PC高位相连而成。</p>
<p><img src="/2021/04/21/MIPS%20addressing%20modes/5.png" alt="pseudodirect addressing"></p>
]]></content>
      <categories>
        <category>computer hardware</category>
      </categories>
  </entry>
  <entry>
    <title>MOS and TTL</title>
    <url>/2021/04/21/MOS%20and%20TTL/</url>
    <content><![CDATA[<p><img src="/2021/04/21/MOS%20and%20TTL/0.jpg" alt="0"></p>
<a id="more"></a>

<p>MOS：金属氧化半导体场效应晶体管</p>
<p>TTL：Transistor-Transistor logic 晶体管-晶体管逻辑电路</p>
]]></content>
      <categories>
        <category>computer hardware</category>
      </categories>
  </entry>
  <entry>
    <title>ROM types</title>
    <url>/2021/04/21/ROM%20types/</url>
    <content><![CDATA[<p><img src="/2021/04/21/ROM%20types/0.jpg" alt="0"></p>
<a id="more"></a>

<ul>
<li>掩模型只读存储器（Masked ROM，MROM）：重合法驱动，根据其交叉处是否有耦合元件MOS管识别0和1.不可写入。</li>
<li>可编程只读存储器（Programmable ROM)：根据熔丝断和未断可区别其所存的信息是0还是1.只能实现一次编程，不得在修改。</li>
<li>可擦除可编程只读存储器（Erasable Programmable ROM)：由<strong>浮动栅雪崩注入型MOS管</strong>构成，又称FAMOS型EPROM。用户需重新改变其状态，可用紫外线照射，驱散浮动栅，再按需要将不同的位置的MOS管D端重新置于正电压，又得出新状态的ROM。<strong><em>另外还可以使用电器方法将存储内容擦除。</em></strong></li>
<li>用电可擦除可编程只读存储器（Electrically Erasable Programmable ROM）：可在联机条件下，用字擦除方式或页擦除方式，即可局部擦写，又可全部擦写，这种EPROM就是EEPROM。</li>
<li>闪速存储器（Flash Memory）擦除，重写速度快。在便携式计算机、工控系统及单片机系统中得到大量应用，近年来将它用于微型计算机中存放I/O驱动程序和参数。</li>
</ul>
]]></content>
      <categories>
        <category>computer hardware</category>
      </categories>
  </entry>
  <entry>
    <title>Software can&#39;t run on different OS based the same architecture</title>
    <url>/2021/01/03/Software%20can&#39;t%20run%20on%20different%20OS%20based%20the%20same%20architecture/</url>
    <content><![CDATA[<h2 id="Software-can’t-run-on-different-OS-based-on-the-same-architecture"><a href="#Software-can’t-run-on-different-OS-based-on-the-same-architecture" class="headerlink" title="Software can’t run on different OS based on the same architecture"></a>Software can’t run on different OS based on the same architecture</h2><p>​    A software that dose run on Windows but not on Linux , both of which are based on x86 architecture might make people feel confused. Because after being assembled into machine code, the most of result are alike. So why the same software ,no any changes, can’t run on different OS?<br>​    One of  reasons is with regard to different OS, software need adding specific information to instruct OS how to load itself.</p>
]]></content>
  </entry>
  <entry>
    <title>The included information of C head files in UNIX</title>
    <url>/2020/05/07/The%20included%20information%20of%20C%20head%20files%20in%20UNIX/</url>
    <content><![CDATA[<h1 id="The-included-information-of-C-head-files-in-UNIX"><a href="#The-included-information-of-C-head-files-in-UNIX" class="headerlink" title="The included information of C head files in UNIX"></a>The included information of C head files in UNIX</h1><ul>
<li>目标文件头，描述目标文件其他部分的大小和位置</li>
<li>代码段，包括机器语言和代码</li>
<li>静态数据段，包含在程序生命周期内分配的数据。（UNIX系统允许程序使用静态数据，它存在于整个程序；也允许使用动态数据，它随程序的需要而增长或缩小。</li>
<li>重定位信息，标记了一些在程序加载进内存时依赖于绝对地址的指令和数据。</li>
<li>符号表，包含未定的剩余标记，如外部引用。</li>
<li>调试信息，包含一份说明目标模块如何编译的简明描述，这样，调试器能够将机器指令关联到C源文件，并使数据结构也变得可读。</li>
</ul>
<p><strong>符号表（symbol table）：一个用来匹配标记名和指令所在内存字的地址的列表</strong></p>
]]></content>
  </entry>
  <entry>
    <title>develpment aspects of microprocessors</title>
    <url>/2021/04/21/develpment%20aspects%20of%20microprocessors/</url>
    <content><![CDATA[<p><img src="/2021/04/21/develpment%20aspects%20of%20microprocessors/0.jpg" alt="0"></p>
<a id="more"></a>

<p>从21世纪初来看，当前通用微处理器的发展重点将在以下几个方面：</p>
<ul>
<li>进一步提高复杂度来提高处理器性能</li>
<li>通过Thread-level/Process-level 并行性的开发提高处理器的性能，即通过开发线程级并行性（Thread-Level Parallelism，TLP）或进程级并行性（Process-Level Parallelism，PLP）来提高性能，简化硬件设计。</li>
<li>将存储器集成到处理器芯片来提高处理器性能</li>
<li>发展嵌入式处理器</li>
</ul>
]]></content>
      <categories>
        <category>computer hardware</category>
      </categories>
  </entry>
  <entry>
    <title>concepts and properties of tree</title>
    <url>/2021/04/21/concepts%20and%20properties%20of%20tree/</url>
    <content><![CDATA[<p><img src="/2021/04/21/concepts%20and%20properties%20of%20tree/0.jpg" alt="0"></p>
<a id="more"></a>

<h3 id="1-Basic-concepts"><a href="#1-Basic-concepts" class="headerlink" title="1. Basic concepts"></a>1. Basic concepts</h3><h5 id="节点和树的度（Degree）"><a href="#节点和树的度（Degree）" class="headerlink" title="节点和树的度（Degree）"></a>节点和树的度（Degree）</h5><p>树中一个结点的孩子个数称为该节点的度。树中节点的最大度数称为树的度。</p>
<h5 id="树的层次（Level），深度（Depth）和高度"><a href="#树的层次（Level），深度（Depth）和高度" class="headerlink" title="树的层次（Level），深度（Depth）和高度"></a>树的层次（Level），深度（Depth）和高度</h5><p>严蔚敏的书规定，根节点所在的层次是第一层。故，深度=高度。</p>
<h5 id="有序树和无序树"><a href="#有序树和无序树" class="headerlink" title="有序树和无序树"></a>有序树和无序树</h5><p>若将树中结点的各子树看成从左至右有次序的（即不能互换），则称该树为有序树，否则为无序树。</p>
<h5 id="路径和路径长度"><a href="#路径和路径长度" class="headerlink" title="路径和路径长度"></a>路径和路径长度</h5><p>树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的，而路径长度是路径上所经过的边的个数。<br>树的路径长度是从树根到每个结点的路径长度。</p>
<h3 id="2-Basic-properties"><a href="#2-Basic-properties" class="headerlink" title="2. Basic properties"></a>2. Basic properties</h3><h5 id="任意树的结点数与其最小高度的关系"><a href="#任意树的结点数与其最小高度的关系" class="headerlink" title="任意树的结点数与其最小高度的关系"></a>任意树的结点数与其最小高度的关系</h5><p>具有n个结点的m叉树的最小高度为：<br>$$<br>\lceil\log_m (n(m-1)+1)\rceil<br>$$</p>
<h5 id="二叉树与度为2的有序树的区别"><a href="#二叉树与度为2的有序树的区别" class="headerlink" title="二叉树与度为2的有序树的区别"></a>二叉树与度为2的有序树的区别</h5><ul>
<li>度为2的树至少有3个结点，而二叉树可以为空</li>
<li>度为2的有序树的孩子的左右次序是相对于另一孩子而言的，若某个结点只有一个孩子，则这个孩子就无须区分其左右次序，而二叉树无论孩子数是否为2，均需确定其左右次序，即二叉树的结点次序不是相对另一结点而言，而是确定的。</li>
</ul>
<h5 id="二叉树结点关系-常用"><a href="#二叉树结点关系-常用" class="headerlink" title="二叉树结点关系(常用)"></a>二叉树结点关系(常用)</h5><p>非空二叉树上的叶子结点数等于度为2的结点数加1，即<br>$$<br>n_0=n_2+1<br>$$</p>
<h5 id="某一层的结点数上限"><a href="#某一层的结点数上限" class="headerlink" title="某一层的结点数上限"></a>某一层的结点数上限</h5><p>非空二叉树第k层上至多有<br>$$<br>2^{k-1}个结点<br>$$</p>
<h5 id="对于完全二叉树，确定结点数n，即确定高度"><a href="#对于完全二叉树，确定结点数n，即确定高度" class="headerlink" title="对于完全二叉树，确定结点数n，即确定高度"></a>对于完全二叉树，确定结点数n，即确定高度</h5><p>$$<br>h=\lceil\log_2(n+1)\rceil或 \lfloor\log_2n\rfloor+1<br>$$</p>
<h5 id="完全二叉树某一结点的深度"><a href="#完全二叉树某一结点的深度" class="headerlink" title="完全二叉树某一结点的深度"></a>完全二叉树某一结点的深度</h5><p>编号为i的结点所在的深度为<br>$$<br>\lfloor\log_2i\rfloor+1<br>$$</p>
<h5 id="完全二叉树奇偶结点数"><a href="#完全二叉树奇偶结点数" class="headerlink" title="完全二叉树奇偶结点数"></a>完全二叉树奇偶结点数</h5><p>若n为奇数，则每个分支节点都有左孩子和右孩子；若n为偶数，则编号最大的分支节点（编号为n/2）只有左孩子，没有右孩子，其余分支节点左，右孩子都有。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>difference between computer architecture and computer organization</title>
    <url>/2021/04/21/difference%20between%20computer%20architecture%20and%20computer%20organization/</url>
    <content><![CDATA[<p><img src="/2021/04/21/difference%20between%20computer%20architecture%20and%20computer%20organization/0.jpg" alt="0"></p>
<a id="more"></a>

<p>计算机体系结构(Computer Architecture)是指机器语言或汇编语言程序所看到的传统机器的属性，包括指令集，数据类型，存储器寻址技术等，<strong>大多属于抽象的属性</strong></p>
<p>计算机组成（Computer Organization）是指如何实现计算机体系结构所体现的属性，它包含对许多程序员来说透明的硬件细节。例如，指令系统属于结构的问题，但指令的实现即如何取指令，分析指令，取操作数，如何运算等都属于组成的问题。因此，当两台机器指令系统相同时，只能认为他们具有相同的结构，至于这两台机器如何实现其指令，完全可以不同，即可以认为它们的组成方式是不同的。<strong>例如，一台机器是否具备乘法指令是一个结构的问题，但实现乘法指令采用什么方式则是一个组成的问题。</strong></p>
<h2 id="王道解释："><a href="#王道解释：" class="headerlink" title="王道解释："></a>王道解释：</h2><p>计算机体系结构（Computer architecture)，是指机器语言或汇编语言程序员所看到的传统机器的属性，包括指令集，数据类型，存储器寻址技术等，大都属于抽象属性。<br>    计算机组成（Computer Organization），是指如何实现计算机体系结构所体现的属性，它包含对许多程序员来说透明的硬件细节。例如，指令系统属于结构问题，但指令的实现即如何取指令，分析指令，取操作数，如何运算等都属于组成的问题。因此，当两台机器指令系统相同时，只能认为它们具有相同的结构，至于这两台机器如何实现其指令，完全可以不同，既可以认为它们的组成方式是不同的。例如，一个机器是否具备乘法指令是一个结构问题，但实现乘法指令采用什么方式（例如直接采用乘法器，亦或者采用加法器实现）则是一个组成的问题。<br>    许多计算机厂商提供一系列结构相同的解散及，而它们的组成却又相当大的差别，即使是同一系列的不同型号机器，其性能和价格差异也很大。例如，IBM System/370结构就包含了多种价位和性能的机位。</p>
]]></content>
      <categories>
        <category>computer hardware</category>
      </categories>
  </entry>
  <entry>
    <title>SRAM and DRAM basic unit circuity  working principle</title>
    <url>/2021/04/21/explanation%20on%20SRAM%20and%20DRAM%20basic%20unit%20circuity%20%20working%20principle/</url>
    <content><![CDATA[<p><img src="/2021/04/21/explanation%20on%20SRAM%20and%20DRAM%20basic%20unit%20circuity%20%20working%20principle/0.jpg" alt="0"></p>
<a id="more"></a>

<p><img src="/2021/04/21/explanation%20on%20SRAM%20and%20DRAM%20basic%20unit%20circuity%20%20working%20principle/1.png" alt="1"></p>
<p>工作原理如下：</p>
<p>读出时：行地址选择和列地址选择有效，T5，T6，T7，T8打开。假设A端为高电平，通过T6送进位线A，经过T8，送进读出放大器，输出。读入时，经过两个写放大器的相反信号分别经过T7，T8送进A’和A端，A‘和A端两端是相反的信号。</p>
<hr>
<p><img src="/2021/04/21/explanation%20on%20SRAM%20and%20DRAM%20basic%20unit%20circuity%20%20working%20principle/2.png" alt="2"></p>
<p>工作原理：</p>
<p>读出时，T4置一预充电信号，接着读选择项打开T2。若Gg有足够多的电荷（即Cg存储的是1），则T1导通且接地，此时读数据线降为低电平，读出“0”。反之，Cg没有足够多的电荷（存储的是0），T1截止，读数据线为高电平，读出“1”。</p>
<p>写入时，数据先到写数据线，再由写选择线打开T3，此时写数据线相当于电容Cg联通，写数据线上是“1”就写入“1”，是“0”就写入“0”。</p>
<hr>
<p><img src="/2021/04/21/explanation%20on%20SRAM%20and%20DRAM%20basic%20unit%20circuity%20%20working%20principle/3.png" alt="3"></p>
<p>工作原理：</p>
<p>读出时，字线上的高电平使T导通，如果Cg中有电荷（表示“1”），经T管在数据线上产生电流，读出为“1”。<br>否则，数据线上不产生电流，视为读出“0”。这里注意，读操作结束时，Cg的电荷已释放完毕，故是破坏性读出，必须再生。</p>
<p>写入时，原理类似。</p>
]]></content>
      <categories>
        <category>computer hardware</category>
      </categories>
  </entry>
  <entry>
    <title>Function pointer</title>
    <url>/2021/04/21/function%20pointer/</url>
    <content><![CDATA[<p><img src="/2021/04/21/function%20pointer/1.jpg" alt="1"></p>
<a id="more"></a>

<h4 id="1-Declare-function-pointer"><a href="#1-Declare-function-pointer" class="headerlink" title="1. Declare function pointer"></a>1. Declare function pointer</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">format: <span class="keyword">return</span> type (*funtionPointerName)(<span class="built_in">list</span> of parameter types)</span><br><span class="line">example:</span><br><span class="line"><span class="keyword">int</span> (*pfunction) (<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line">assign value:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">pfunctioin=sum;</span><br><span class="line">call function through pointer:</span><br><span class="line"><span class="keyword">int</span> result=pfunction(<span class="number">4</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<h4 id="2-Declare-array-of-function-pointer"><a href="#2-Declare-array-of-function-pointer" class="headerlink" title="2.Declare array of function pointer"></a>2.Declare array of function pointer</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*pfun[<span class="number">3</span>])(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>

<h4 id="3-Function-pointer-as-an-argument-of-other-functions"><a href="#3-Function-pointer-as-an-argument-of-other-functions" class="headerlink" title="3. Function pointer as an argument of other functions"></a>3. Function pointer as an argument of other functions</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">any_function</span><span class="params">(<span class="keyword">int</span>(*pfun)(<span class="keyword">int</span> a,<span class="keyword">int</span> b),<span class="keyword">int</span> x.<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> ,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//call any_function</span></span><br><span class="line">any_function(sum,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>kernel</title>
    <url>/2021/04/21/kernel/</url>
    <content><![CDATA[<p><img src="/2021/04/21/kernel/0.jpg" alt="0"></p>
<a id="more"></a>

<h3 id="Into-Protection-Mode"><a href="#Into-Protection-Mode" class="headerlink" title="Into Protection Mode"></a>Into Protection Mode</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">From real mode into protection mode, there are five necessary steps:</span><br><span class="line"></span><br><span class="line">1: load global descriptor register</span><br><span class="line"><span class="code">	xor eax,eax</span></span><br><span class="line"><span class="code">	mov ax,cs	</span></span><br><span class="line"><span class="code">	shl eax,4</span></span><br><span class="line"><span class="code">	add eax,LABEL_GDT</span></span><br><span class="line"><span class="code">	mov dword [GdtPtr+0x02],eax</span></span><br><span class="line"><span class="code">	lgdt	[GdtPtr]</span></span><br><span class="line"></span><br><span class="line">2:	switch off interrupt</span><br><span class="line"><span class="code">	cli</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line">3:	open A20</span><br><span class="line"><span class="code">	in al,92h</span></span><br><span class="line"><span class="code">	or al,0000_0010h</span></span><br><span class="line"><span class="code">	out 92h,al</span></span><br><span class="line"></span><br><span class="line">4:	set PE in cr0 to 1</span><br><span class="line"><span class="code">	mov eax,cr0</span></span><br><span class="line"><span class="code">	or eax,1</span></span><br><span class="line"><span class="code">	mov cr0,eax</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line">5:	jump into protected mode</span><br><span class="line"><span class="code">	jmp dword SelectorCode32:0</span></span><br></pre></td></tr></table></figure>



<h3 id="Set-up-paging"><a href="#Set-up-paging" class="headerlink" title="Set up paging"></a>Set up paging</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1: initialize page directory table and page page table.</span><br><span class="line">2: set cr3 to the initial position of page directory table</span><br><span class="line">3: set the PG -the highest bit in CR0 to 1</span><br><span class="line">4: nop</span><br></pre></td></tr></table></figure>



<h3 id="Interrupt-under-protected-mode"><a href="#Interrupt-under-protected-mode" class="headerlink" title="Interrupt under protected mode"></a>Interrupt under protected mode</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1:Interrupt Descriptor Table(IDT) replaces Interrupt Vector(IVT).</span><br><span class="line">2:BIOS interrupt is invalid.</span><br></pre></td></tr></table></figure>



<h3 id="Interrupt-and-Exception"><a href="#Interrupt-and-Exception" class="headerlink" title="Interrupt and Exception"></a>Interrupt and Exception</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Exception has three forms:</span><br><span class="line">Fault , Trap , Abort</span><br><span class="line"></span><br><span class="line">Interrupt has two forms:</span><br><span class="line">external interrupt(whether to be maskable) , int n</span><br></pre></td></tr></table></figure>



<h3 id="Special-descriptor-in-GDT"><a href="#Special-descriptor-in-GDT" class="headerlink" title="Special descriptor in GDT"></a>Special descriptor in GDT</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1: Local descriptor table(LDT) descriptor</span><br><span class="line">2: Task-state segment(TSS) descriptor</span><br><span class="line">3: Gate descriptor</span><br><span class="line">4: Page directory descriptor</span><br><span class="line">5: Page table descriptor</span><br></pre></td></tr></table></figure>



<h3 id="Pass-parameters-with-STACK"><a href="#Pass-parameters-with-STACK" class="headerlink" title="Pass parameters with STACK"></a>Pass parameters with STACK</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="FAT12-recognized-by-Linux"><a href="#FAT12-recognized-by-Linux" class="headerlink" title="FAT12 recognized by Linux"></a>FAT12 recognized by Linux</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">If we organize a floppy with FAT12, it needn't writing for .bin file with dd. This floppy can be mounted then we use cp to copy file into this floppy. Linux will automatically complete root directory,FAT1 and FAT2.</span><br></pre></td></tr></table></figure>



<h3 id="what’s-going-to-do-in-loader"><a href="#what’s-going-to-do-in-loader" class="headerlink" title="what’s going to do in loader"></a>what’s going to do in loader</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1: get memory info</span><br><span class="line">2: find out kernel.bin in root directory and load it</span><br><span class="line">3: into protect mode</span><br><span class="line">4: display memory info (not necessary)</span><br><span class="line">5: set up paging </span><br><span class="line">6: after loading kernel into memory, place it according to program header table.</span><br></pre></td></tr></table></figure>



<h3 id="BIOS-Interrupt"><a href="#BIOS-Interrupt" class="headerlink" title="BIOS Interrupt"></a>BIOS Interrupt</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">int 10h      ah=13h</span><br><span class="line">Function: display char</span><br><span class="line">al:output pattern</span><br><span class="line">bl:display property</span><br><span class="line">bh:page number</span><br><span class="line">cx:string length</span><br><span class="line">dh:row </span><br><span class="line">dl:col</span><br><span class="line">es:bp string address</span><br><span class="line"></span><br><span class="line">int 13h      ah=02h</span><br><span class="line">Function: read section</span><br><span class="line">al:how many sections to read</span><br><span class="line">es:bx buffer address</span><br><span class="line">ch: cylinder number</span><br><span class="line">cl: section number</span><br><span class="line">dh:	header number</span><br><span class="line">dl: driver</span><br><span class="line">output:</span><br><span class="line">CF=0 succeed.  ah=0  al=how many section to read</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>OSDev</category>
      </categories>
  </entry>
  <entry>
    <title>memory</title>
    <url>/2021/04/21/memory/</url>
    <content><![CDATA[<p><img src="/2021/04/21/memory/0.jpg" alt="0"></p>
<a id="more"></a>

<p>一. 存储器分类</p>
<p>（1） 半导体存储器   TTL 、MOS   易失</p>
<p>（2）磁表面存储器   磁头，磁载体   非易失</p>
<p>（3） 磁芯存储器     硬磁材料 ，环状元件  非易失</p>
<p>（4） 光盘存储器     激光 、激光材料   非易失</p>
<p><strong>寄存器在I/O端口中也有</strong></p>
<p>Cache 一部分在CPU中，一部分在CPU外</p>
<p>利用软硬件相结合的方式将不同介质的存储器连接成一个整体。 </p>
<p>主存-辅存  解决主存容量不够 。利用软硬件相结合的方法连接成一个整体。</p>
<p>缓存-主存   为了解决主存的速度不够。用硬件的方法连接成一个整体。因为主要是为了解决主存和CPU的速度问题，故需要非常快。</p>
<p>主存-辅存  这个整体称为虚拟存储器。地址称为：虚地址，逻辑地址</p>
<p>缓存-主存   这个层次结构用主存储器的地址。实际上缓存是按内容来查找的。</p>
<p>主存用到的地址称为实地址，也即物理地址。</p>
<hr>
<p>Q1：主存的基本组成</p>
<p>Q2：主存与CPU之间的联系</p>
<p>Q3：主存中存储单元地址的分配</p>
<p>Q4：主存的技术指标</p>
<p>主存的基本构成：存储体，MAR，MDR，译码器等。</p>
<p>MAR经过译码器进行译码才能选定指定的存储单元。</p>
<p>主存遍址单位是字节，每一个字节都一个地址。</p>
<p>12345678H  在主存的存储单元中如何存储。</p>
<ul>
<li>高位字节地址为字地址（高位字节在低地址，低位字节在高地址）-大端方式</li>
<li>低位字节地址为字地址-小端方式</li>
</ul>
<p>x86系列的机器采用的是小尾方式。</p>
<p>两种类型的机器进行通讯会产生问题。</p>
<p><img src="/2021/04/21/memory/1.png" alt="1"></p>
<p>读出时间：从给出地址信号到数据线有稳定的数据输出。</p>
<p>存取周期&gt;存取时间</p>
<hr>
<p><img src="/2021/04/21/memory/2.png" alt="2"></p>
<p>半导体芯片的片选线一般有两种方式：</p>
<p><img src="/2021/04/21/memory/3.png" alt="3"></p>
<p>对 八个芯片相同的地址同时进行操作，每个芯片给出一位。<br>每一组八个芯片要同时进行工作才能够在每个芯片当中读出或写入一位二进制信号。<br>每八片的片选线连接在一起。<br>CPU地址中0<del>16K-1  分配到第一组芯片中。<br>16K</del>32K-1 分配到第二组芯片中。后面同理</p>
<p>如果要读的地址是65535，则选择第四组芯片（低电平有效），其余芯片组高电平。然后在八个芯片的同一地址处各读出一位，构成一个B，送到CPU中。</p>
<hr>
<h4 id="半导体存储芯片的译码驱动方式"><a href="#半导体存储芯片的译码驱动方式" class="headerlink" title="半导体存储芯片的译码驱动方式"></a>半导体存储芯片的译码驱动方式</h4><ul>
<li>线选法：不适合地址容量大的内存，布局的时候，是布局成线性的数组。</li>
<li>重合法：把所有的存储单元布局成二位的存储阵列，可以提高芯片集成度。</li>
</ul>
<hr>
<h4 id="RAM：内存就是由RAM构成的。"><a href="#RAM：内存就是由RAM构成的。" class="headerlink" title="RAM：内存就是由RAM构成的。"></a>RAM：内存就是由RAM构成的。</h4><ul>
<li>静态RAM（SRAM）</li>
<li>动态RAM（DRAM）</li>
</ul>
<hr>
<h4 id="静态RAM-利用触发器存储0-1"><a href="#静态RAM-利用触发器存储0-1" class="headerlink" title="静态RAM:利用触发器存储0,1"></a>静态RAM:利用触发器存储0,1</h4><p>(1)：静态RAM基本电路的读操作的解释</p>
]]></content>
      <categories>
        <category>computer hardware</category>
      </categories>
  </entry>
  <entry>
    <title>popular BUS standards</title>
    <url>/2021/04/21/popular%20BUS%20standards/</url>
    <content><![CDATA[<p><img src="/2021/04/21/popular%20BUS%20standards/0.jpg" alt="0"></p>
<a id="more"></a>

<h3 id="ISA总线"><a href="#ISA总线" class="headerlink" title="ISA总线"></a>ISA总线</h3><p>​    ISA（Industiral Standard Architecture)总线是IBM为了采用全16位的CPU而推出的，又称为AT总线，它使用独立于CPU的总线时钟，一年春CPU可以采用比总线频率更高的时钟，有利于CPU性能的提高。由于ISA总线没有支持总线仲裁的硬件逻辑，因此它不能支持多台主设备系统，而且ISA上的所有数据的传送必须通过CPU或DMA接口来管理，因此使CPU花费大量时间来控制与外部设备交换数据。ISA总线时钟频率为8MHz，最大传输率为16MBps，数据线为16位，地址线为24位。</p>
<hr>
<h3 id="EISA总线"><a href="#EISA总线" class="headerlink" title="EISA总线"></a>EISA总线</h3><p>​    EISA（Extended Industrial Standard Architecture)是一种在ISA基础上扩充开放的总线标准，与ISA完全兼容，从CPU中分离出了总线控制权，是一种具有智能化的总线，能支持多个总线主控器和突发方式（成块传输）的传输。EISA总线的时钟频率为8MHz，最大传输率可达33MBps，数据总线为32位，地址总线为32位，扩充DMA访问范围达2^32</p>
<hr>
<h3 id="VESA总线"><a href="#VESA总线" class="headerlink" title="VESA总线"></a>VESA总线</h3><p>​    VESA是由VESA（Video Electronic Standard Association，视频电子标准协会）提出的局部总线标准，又称为VL-BUS（Local BUS）总线。<strong>所谓的局部总线，是指在系统外为两个以上的模块提供高速传输信息通道。</strong>VL-BUS是由CPU总线演化而来的，采用CPU的时钟频率达33MHz，数据线为32位，可通过扩展槽扩展到64位，配有局部总线控制器，最大传输率达133MBps。通过局部总线控制器，将高速I/O设备直接挂在CPU上，实现CPU与高速I/O设备之间的高速数据交换。</p>
<hr>
<h3 id="PCI总线"><a href="#PCI总线" class="headerlink" title="PCI总线"></a>PCI总线</h3><p>​    随着图形用户接口（Graphical User Interface ，GUI）和多媒体技术在PC系统的广泛应用，ISA总线和EISA总线由于受带宽的限制，已不能适应系统工作的要求，成为整个系统的主要瓶颈。因此对总线提出了更高的性能要求，促使总线技术进一步发展。<br>​        1991年下半年，Intel公司首先提出PCI（Peripheral Component Interconnect ，外部部件互连）总线的概念，并联合IBM、COMPAQ、APPLE、DEC、AST、HP等计算机业界大户，成立了PCI集团PCIIG（PIC Special Interest Group)，于1992年6月22日推出了PCI1.0版，1995和1999又先后推出了2.1和2.2版，PCI总线已成为现代计算机中最常用的总线之一，其主要特点如下：</p>
<pre><code>1. ​    高性能。PCI总线是一种不依附某个具体处理器的局部总线。它为系统提供了一个高速的数据传输通道，与CPU时钟频率无关，自身采用33MHz和66MHz的总线时钟，数据线为32位，可扩展到64位，传输速率从132MBps可升级到528MBps。它支持突发工作方式，这种方式是指若被传送的数据在主存中连续存放，则在访问此组数据时，只需给出第一个数据的地址，占用一个时钟周期，其后每个数据的传送各占一个时钟周期，不必每次给出各个数据的地址，因此可提高传输速率。
2.    良好的兼容性。PCI总线部件和插件接口相对于处理器是独立的，它支持所有的目前和将来不同结构的处理器，因此具有相对长的生命周期。PCI总线与ISA、EISA总线均可兼容，可以转换为标准的ISA和EISA。
3.    支持即插即用（Plug and play)，即任何扩展卡只要插入系统便可工作。PCI设备中配有存放设备具体信息的寄存器，这些信息可供BIOS和操作系统层的软件自动配置PCI总线部件和插件，使系统使用方便，无需进行复杂的手动配置。
4. ​    具有与处理和存储器子系统完全并行操作的能力。PCI总线可视为CPU与外设之间的一个中间层，它通过PCI桥路与CPU相连。PCI桥路有多级缓冲，可把一批数据快速写入缓冲器中，在这些数据不断写入PCI设备过程中，，可真正实现与处理器/存储器子系统的安全并发工作。
5.    支持多主设备能力。主设备即对总线有控制权的设备，PCI支持多主设备，即允许任何主设备和从设备之间实现点对点对等存取，体现了接纳设备的高度灵活性。
6.    提供数据和地址奇偶校验功能，保证了数据的完整和准确。
7.    支持两种电压标准：5V和3.3V。3.3~5V的组件技术可以是电压平滑过渡。3.3V电压的PCI总线可以用于便携式微型计算机中。
8.    可扩充性好。当PCI总线驱动能力不足时，可以采用层次结构。
9.    软件兼容性好。PCI部件可以完全兼容现有的驱动程序和应用程序。设备驱动程序可被移植到各类平台上。
10.    采用多路复用技术，减少了总线引脚个数。</code></pre><p>随着网络的告诉法杖以及其他周边设备的技术革新，诸如千兆网卡之类的设备对PCI总线提出了更高的要求。Intel公司近年来又推出了PCI-Express总线，它采用了类似网络传输TCP/IP协议的分层结构和数据帧逐层传递的模式。</p>
<hr>
<h3 id="AGP总线"><a href="#AGP总线" class="headerlink" title="AGP总线"></a>AGP总线</h3><p>​    随着多媒体计算机的普及，对三维技术的应用也越来越广。处理三维数据不仅要求有惊人的数据量，而且要求有更宽广的数据传输带宽。Intel于1996年7月又推出了AGP（Accelerated Graphics Port），这是显示卡专用的局部总线，基于PCI2.1版规范并进行扩充修改而成，它采用点对点通道方式，以66.7MHz的频率直接与主存联系，以主存作为帧缓冲器，实现了高速存取。最大数据传输率为266MBps，是传统PCI总线带宽的2倍。AGP还定义了一种“双激励”（Double Pumping）的传输技术，能在一个时钟的上，下沿双向传递数据，这样，AGP实现的传输频率为133MHz，最大数据传输率可增为533MBps。后来又依次推出了AGP2X, AGP4X, AGP8X多个版本，数据传输速率可达2.1GBps。</p>
<hr>
<h3 id="RS-232C总线"><a href="#RS-232C总线" class="headerlink" title="RS-232C总线"></a>RS-232C总线</h3><p>​    RS-232（RS即Recommended Standard ，232位标识号，C表示修改次数）是由美国电子工业协会EIA（Electronic Industries Association）推荐的一种串行通信总线标准，它是应用串行二进制交换的数据终端设备和数据通信设备之间的标准接口。<br>​    众所周知，计算机之间传送的是数字信号，它要求传送的频带很宽，而计算机远程通信通常是通过载波电话传送的，不可能有这样的宽的频带。如果数字信号直接进行通信，经过传输后，必然发生畸变。因此在发送端必须通过调制器将数字信号转换成模拟信号，即对载波电话线上载波进行调制；而在接收端又必须用解调器检出从发送端来的模拟信号，并恢复为原来的数字信号。</p>
<hr>
<h3 id="USB总线"><a href="#USB总线" class="headerlink" title="USB总线"></a>USB总线</h3><p>​    USB（Universial Serial Bus）通用串行总线是Compaq，DEC，IBM，Intel，Microsoft，NEC（Japan）和Northe Telecom（Canada）等七大公司于1994年11月联合开发的计算机串行接口总线标准，1996年1月颁布了USB1.0版本。它基于通用连接技术，实现外设的简单快速连接，达到方便用户、降低成本、扩展PC连接外设范围的目的。用户可以将几乎所有的外设装置，包括显示器、键盘、鼠标、打印机、扫描仪、数码相机、U盘、调制解调器等直接插入标准USB插口。还可以将一些USB外设进行串接，使一大堆设备共用PC上的端口。其特点如下：</p>
<pre><code>1. 具有真正的即插即用特征。用户可以在不关机的情况下很方便地对外设实行安装和拆卸，主机可按外设的增删情况自动配置系统资源，外设装置驱动程序的安装，删除均自动实现。
2.  具有很强的连接能力。使用USB HUB（USB集线器）实现系统扩展，最多可链式连接127个外设到同一系统。
3.  数据传输率有两种，即采用普通无屏蔽双绞线，速度可达1.5Mbps，若用带屏蔽的双绞线，速度可达12Mbps。USB2.0的数据传输率最高可达480Mbps。
4.  标准统一。USB的引入减轻了对目前PC中所有标准接口的需求，如串口的鼠标、键盘、并口的打印机、扫描仪、IDE接口的硬盘，都可以改成以统一的USB标准接入系统，从而减少了对PC插槽的需求，节省空间。
5. 连接电缆轻巧，电源体积缩小。USB使用的4芯电缆2条用于信号连接，2条用于电源/地，可为外设提供+5V的直流电源，方便用户。
6. 生命力强。USB是一种开放型的不具有专利版权的工业标准，它是由一个标准化组织“USB实施者论坛”制定出来的，因此不存在专利版权问题，USB规范具有强大的生命力。</code></pre>]]></content>
      <categories>
        <category>computer hardware</category>
      </categories>
  </entry>
  <entry>
    <title>proving process of number relationship between child and parent in tree</title>
    <url>/2021/04/21/proving%20process%20of%20number%20relationship%20between%20child%20and%20parent%20in%20Tree/</url>
    <content><![CDATA[<p><img src="/2021/04/21/proving%20process%20of%20number%20relationship%20between%20child%20and%20parent%20in%20Tree/0.jpg" alt="0"></p>
<a id="more"></a>

<h3 id="性质表述："><a href="#性质表述：" class="headerlink" title="性质表述："></a>性质表述：</h3><p>如果对一棵有n个结点的完全二叉树的结点按层序编号（从左到右），则对任一结点i，有<br>（1）如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲PARENT(i)是结点<br>$$<br>\lfloor i/2 \rfloor<br>$$<br>（2）如果2i&gt;n，则结点i无左孩子；否则其左孩子LCHILD(i)是结点2i.</p>
<p>（3）如果2i+1&gt;n，则结点i无右孩子；否则其右孩子RCHILD(i)是结点2i+1</p>
<h3 id="证明（数学归纳法）："><a href="#证明（数学归纳法）：" class="headerlink" title="证明（数学归纳法）："></a>证明（数学归纳法）：</h3><p>对于i=1，由完全二叉树的定义，其左孩子结点是2，若2&gt;n则左结点不存在，否则2是它的左孩子结点；同理对结点3也成立<br>对于i&gt;1，分两种情况讨论；（1）若结点i是第j层的第一个结点，那么其左孩子结点应为第j+1层的第一个结点，编号为<br>$$<br>2^j-1+1=2^j=2(2^{j-1})=2i<br>$$<br>同样，若2i&gt;n则i的左孩子不存在，反之存在；同理其有孩子结点为2i+1.</p>
<p>（2）若结点i是第j层的某一个结点（不一定第一个结点），由（1）可知，其左右孩子节点分别为2i，2i+1.则对于第i+1个结点，</p>
<p>其左孩子为2i+1+1=2(i+1)，右孩子结点为2(i+1)+1.证毕。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>string matching KMP algorithm</title>
    <url>/2021/04/21/string%20matching%20KMP%20algorithm/</url>
    <content><![CDATA[<p><img src="/2021/04/21/string%20matching%20KMP%20algorithm/0.jpg" alt="0"></p>
<a id="more"></a>

<p>KMP算法利用子串的结构特点（前后缀有相同的部分）来减少子串与主串的比较次数。</p>
<p>前缀：必包含主串的第一个字符，且不包含主串的最后一个字符的主串的子串。<br>后缀：必包含主串的最后一个字符，且不包含主串的第一个字符的主串的子串。<br>例如：<br>    主串：a               后缀=前缀=∅<br>    主串：abab        前缀={a,ab,aba}  后缀={b,ab,bab}  故前后缀公共部分为{ab}</p>
<p>算法的基本思想为：（设主串为s，子串为p）<br>利用指向主串的指针i，和指向子串的指针j，当s[i] != p[j]时，子串指针退回到某个已知位置<strong>next[j]</strong>，而i指针不需要回退。<strong>next[j]</strong>的形成是利用子串本身的特殊结构，即p[1…j]具有相同的前后缀。该算法的难以理解的地方在于<strong>next</strong>数组的递归求出。</p>
<p><strong>next</strong>数组的递归求解：<br>（1）：求解next[j+1]时，设next[j]=k，若p[k]=p[j]，则next[j+1]=next[j]+1;<br>（2）：若p[k] != p[j]。此时，尝试p[next[k]] 是否等于p[j]。这样做的原因在于，在每次求解next[j+1]时，都将该问题看作是一个新的模式匹配，而主串和子串都是原题中的子串。故，在比较p[k]=p[j] 失败时，继续往后推导，使得在第二个问题中，当主串（即子串）的p[j]与子串的p[k]不匹配时，通过继续往低位子串寻找，找到一个位置<strong>k’</strong>，同时有<strong>p[k’]=p[j]</strong>，这样就意味着，主串（即子串）j+1前面有<strong>k’</strong>个和子串的<strong>k’</strong>前的<strong>所有</strong>相匹配，故next[j+1]=<strong>k’+1</strong>。<br>（3）： 若一直往后递归都没有找到某个位置的字符p[t]=p[j]，则<strong>next[j+1]=1</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stringmatching.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmpMatching</span><span class="params">(<span class="keyword">char</span> mstr[],<span class="keyword">int</span> msize, <span class="keyword">char</span>* sstr,<span class="keyword">int</span> ssize)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* next = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * msize);</span><br><span class="line">	constructNext(sstr, ssize, next);</span><br><span class="line">	<span class="keyword">int</span> mpointer = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> spointer = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	char mstr[] = &#123; '0','a','b','a','a','b','c','a','b','a' &#125;;</span></span><br><span class="line"><span class="comment">	char sstr[] = &#123;'0','a','b','b'&#125;;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span> (; mpointer &lt;= msize; mpointer++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (spointer != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (mstr[mpointer++] == sstr[spointer++]&amp;&amp;spointer&lt;=ssize);</span><br><span class="line">			<span class="keyword">if</span> (spointer &gt; ssize&amp;&amp;mstr[mpointer<span class="number">-1</span>]==sstr[spointer<span class="number">-1</span>])</span><br><span class="line">				<span class="keyword">return</span> mpointer - ssize;</span><br><span class="line">			mpointer--;</span><br><span class="line">			spointer = next[--spointer];</span><br><span class="line">		&#125;</span><br><span class="line">		spointer = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">constructNext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* sstr,<span class="keyword">int</span> ssize,<span class="keyword">int</span>*  next)</span> </span>&#123;</span><br><span class="line">	next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	next[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= ssize; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> k = next[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">while</span> (sstr[i - <span class="number">1</span>] != sstr[k]) &#123;</span><br><span class="line">			k = next[k];</span><br><span class="line">			<span class="keyword">if</span> (k == <span class="number">0</span>)&#123;</span><br><span class="line">				next[i] = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (k!=<span class="number">0</span>&amp;&amp;sstr[i - <span class="number">1</span>] == sstr[k])</span><br><span class="line">			next[i] = k + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>signal types in control bus</title>
    <url>/2021/04/21/signal%20types%20in%20control%20bus/</url>
    <content><![CDATA[<p><img src="/2021/04/21/signal%20types%20in%20control%20bus/0.jpg" alt="0"></p>
<a id="more"></a>

<p>控制总线上常见的控制信号有：</p>
<ul>
<li>总线请求</li>
<li>总线允许</li>
<li>中断请求</li>
<li>中断响应</li>
<li>存储器写</li>
<li>存储器读</li>
<li>I/O读</li>
<li>I/O写</li>
<li>时钟：用来同步各种操作</li>
<li>复位：初始化所有部件</li>
<li>传输响应：表示数据已被接受，或已将数据送至数据总线上。</li>
</ul>
]]></content>
      <categories>
        <category>computer hardware</category>
      </categories>
  </entry>
  <entry>
    <title>structures for composition</title>
    <url>/2021/04/21/structures%20for%20composition/</url>
    <content><![CDATA[<p><img src="/2021/04/21/structures%20for%20composition/0.jpg" alt="0"></p>
<a id="more"></a>



<ol>
<li>It’s time you did something = you should have done it already or started  it. <strong>We often use this structure to criticize or complain:</strong></li>
</ol>
<ul>
<li><p>It’s 10 o’clock and he’s still in bed. It’s time  he got up.</p>
</li>
<li><p>You’re very selfish. It’s high time you realized that you’re not the most important person in the world. </p>
</li>
</ul>
<hr>
<ol start="2">
<li>If…should…:</li>
</ol>
<ul>
<li>If Tom should phone while I’m out, tell him I’ll phone him back later. (<em>If Tom should phone</em> is similar to <em>if Tom phones</em> .With should, the speaker feels that the possibility is <strong>smaller</strong> )</li>
<li>I’ve left the washing outside. If it should rain, can you bring it in?</li>
</ul>
<p><strong><em>You can also put should at the beginning of these sentences (Should something happen… ):</em></strong></p>
<ul>
<li>Should Tom phone, can you tell him I’ll phone him back later?</li>
</ul>
<hr>
<ol start="3">
<li>You can use <strong>any</strong> and <strong>no</strong> + comparatives (any longer/no bigger etc.):</li>
</ol>
<ul>
<li>I’ve waited long enough. I’m not waiting <strong>any longer</strong></li>
<li>We expected their house to be very big  but it’s no bigger than ours.</li>
<li>Yesterday you said you felt ill. Do you feel any better today?</li>
<li>This hotel is better than the other one and it’s no more expensive.</li>
</ul>
<hr>
<ol start="4">
<li><p><strong>may</strong>  and <strong>might</strong></p>
<p>We use <strong>may</strong> or <strong>might</strong> to say that something is a possibility. Usually you can use may or might, so you can say:</p>
<ul>
<li>It may be true. or  It might be true.</li>
<li>She might know. or She may know.</li>
</ul>
<p>For the past we use <strong>may have (done)</strong> or <strong>might have (done)</strong>:</p>
<ul>
<li><p>A: I wonder why Kay didn’t answer the phone.</p>
<p>B: She <strong>may have</strong> been asleep. (= perhaps you left it in the shop).</p>
</li>
<li><p>A: I can’t find my bag anywhere.</p>
<p>B: You <strong>might have</strong> left it in the shop. (= perhaps you left it in the shop).</p>
</li>
<li><p>A: I was surprised that Sarah wasn’t  at the meeting.</p>
<p>B: She <strong>might not have</strong> known about it.</p>
</li>
<li><p>A: I wonder why Colin was in such a bad mood yesterday.</p>
<p>B: He <strong>may not have</strong> been feeling well.</p>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="5">
<li><strong>should</strong> and <strong>should have (done)</strong></li>
</ol>
<ul>
<li><strong>should</strong>: We use <strong>should</strong> when something is not right or what we expect. <strong><em>OR</em></strong> We use should to say that we expect something to happen:<ul>
<li>Those boys shouldn’t be playing football at this time. They should be at school. </li>
<li>She’s been studying hard for the exam, so she should pass.</li>
</ul>
</li>
<li><strong>should have (done)</strong>:  ‘You should have done something’ = <strong>you didn’t do it</strong> but it would have been the right thing to do:<ul>
<li>I’m feeling sick. I <strong>shouldn’t have eaten</strong> so much chocolate.</li>
<li>I wonder why they ‘re so late. They <strong>should have been here</strong> an hour ago.</li>
</ul>
</li>
</ul>
<hr>
<ol start="6">
<li>Subjunctive Structures (虚拟语气结构)</li>
</ol>
<ul>
<li><p><strong>If sb did … , sb would do something. ** We are talking about the **present</strong>.</p>
</li>
<li><p>If I found a wallet in the street, I would take it to the police.<br>  (NOTE: Here, I am not thinking about a <strong>real</strong> possibility; I’m <strong>imagining</strong> the situation and doesn’t expect to find a wallet in the street.)</p>
</li>
<li><p>I’d be very frightened if somebody pointed a gun at me.</p>
</li>
<li><p><strong>if sb had done something, sb would have done something.</strong>  It’s like the above structure, but we are talking about the <strong>past</strong> at this moment.</p>
<ul>
<li>If he had been looking where he was going , he wouldn’t have walked into the wall.</li>
<li>The view was wonderful. If I had had a camera, I would have taken some photographs. </li>
</ul>
</li>
</ul>
<hr>
<ol start="7">
<li>about wish …. next time to note…</li>
</ol>
<hr>
<ol start="8">
<li>would like to have done something (=I regret now that I <strong>didn’t</strong> or I <strong>couldn’t</strong> do something):</li>
</ol>
<ul>
<li>It’s a pity we didn’t see Val when we were in London. I <strong>would like to have seen</strong> her again.</li>
<li>We’d like to have gone on holiday but we didn’t have enough money.</li>
</ul>
<p><strong><em>Also: You can use the same structure after would love/ would hate/ would prefer</em></strong></p>
<p><strong><em>Although would love/hate/prefer are usually followed by to (infinitive), would mind is followed by -ing</em></strong>  </p>
<hr>
<ol start="9">
<li>Something needs doing = <strong>something needs to be done</strong></li>
</ol>
<ul>
<li>The batteries in the radio need changing. (=they need to be changed)</li>
<li>Do you think my jacket needs cleaning?  (=…needs to be cleaned)</li>
<li>It’s a difficult problem. It needs thinking about very carefully.</li>
</ul>
<hr>
<ol start="10">
<li>We often use hardly +any/anybody/anyone/anything/anywhere:</li>
</ol>
<ul>
<li><p>A: How much money have you got?</p>
<p>B: <strong>Hardly any.</strong></p>
</li>
<li><p>I’ll have to go shopping. We’ve got <strong>hardly any</strong> food.</p>
</li>
<li><p>The exam results were very bad. <strong>Hardly anybody</strong> in our class passed.</p>
</li>
</ul>
<hr>
<ol start="11">
<li><strong>in case</strong> AND <strong>in case of</strong></li>
</ol>
<ul>
<li>Ann might phone tonight. I don’t want to go out in case she phones.(because it’s possible she will phone)</li>
<li>I’ll draw a map for you in case you can’t find our house.(=because it’s possible you won’t be able to find it)</li>
</ul>
<p><em>We use just in case for a smaller possibility</em></p>
<ul>
<li>I don’t think it will rain but I’ll take an umbrella just in case.(=just in case it rains)</li>
</ul>
<p><em>in case of is not the same as in case. In case of …=’if there is’  (especially in notices etc)</em></p>
<ul>
<li>In case of fire, please leave the building as quickly as possible.</li>
<li>In case of emergency, telephone this number.</li>
</ul>
<hr>
<ol start="12">
<li>Emphatic structure</li>
</ol>
<p>It is/was not until +emphasized part + that +other parts.</p>
<ul>
<li>He didn’t go to bed until his wife came back.</li>
<li>It was not until his wife came back that he went to bed.</li>
<li>As was discussed, it was not until the 19th century that the newspaper became dominant pre-electronic and in the company of periodical.</li>
</ul>
]]></content>
      <categories>
        <category>grammar</category>
      </categories>
  </entry>
  <entry>
    <title>traversal of binary tree</title>
    <url>/2021/04/21/traversal%20of%20binary%20tree/</url>
    <content><![CDATA[<p><img src="/2021/04/21/traversal%20of%20binary%20tree/0.jpg" alt="0"></p>
<a id="more"></a>

<h4 id="Chain-storage-definition"><a href="#Chain-storage-definition" class="headerlink" title="Chain storage definition"></a>Chain storage definition</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BitNode,*BiTree;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="PreOrder-recursive"><a href="#PreOrder-recursive" class="headerlink" title="PreOrder (recursive)"></a>PreOrder (recursive)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        visit(T);</span><br><span class="line">        preOrder(T-&gt;lchild);</span><br><span class="line">        preOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="InOrder-recursive"><a href="#InOrder-recursive" class="headerlink" title="InOrder (recursive)"></a>InOrder (recursive)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">    inOrder(T-&gt;lchild);</span><br><span class="line">    visit(T);</span><br><span class="line">    inOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AfterOrder-recursive"><a href="#AfterOrder-recursive" class="headerlink" title="AfterOrder(recursive)"></a>AfterOrder(recursive)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        afterOrder(T-&gt;lchild);</span><br><span class="line">        afterOrder(T-&gt;rchild);</span><br><span class="line">        visit(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="InOrder-non-recursive"><a href="#InOrder-non-recursive" class="headerlink" title="InOrder(non-recursive)"></a>InOrder(non-recursive)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    initStack(S); <span class="comment">//initialize a stack</span></span><br><span class="line">    BiTree p=T;   <span class="comment">// moving pointer</span></span><br><span class="line">    <span class="keyword">while</span>(p||!isEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            push(S,p);</span><br><span class="line">            p=p-&gt;lchild;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pop(S,p);</span><br><span class="line">            visit(p);</span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PreOrder-non-recursive"><a href="#PreOrder-non-recursive" class="headerlink" title="PreOrder(non-recursive)"></a>PreOrder(non-recursive)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    initStack(S); <span class="comment">//initialize a stack</span></span><br><span class="line">    BiTree p=T;</span><br><span class="line">    <span class="keyword">while</span>(p||!isEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            visit(p);</span><br><span class="line">            push(S,p);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pop(S,p);</span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LevelOrder"><a href="#LevelOrder" class="headerlink" title="LevelOrder"></a>LevelOrder</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    InitQueue Q; <span class="comment">//initialize a queue;</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    enQueue(Q,p);</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">        deQueue(Q,p);</span><br><span class="line">        visit(p);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=null)</span><br><span class="line">            enQueue(Q,p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=null)</span><br><span class="line">            enQueue(Q.p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>x86 instruction</title>
    <url>/2021/04/20/x86%20Instructions/</url>
    <content><![CDATA[<p><img src="/2021/04/20/x86%20Instructions/3.jpg" alt="3"></p>
<a id="more"></a>

<h3 id="Master-boot-sector"><a href="#Master-boot-sector" class="headerlink" title="Master boot sector"></a>Master boot sector</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Nomally, 0 head 0 cylinder 1 sector is the Master boot sector</span></span><br><span class="line"><span class="comment">//to prevent reading fault data, master boot sector's last two binary</span></span><br><span class="line"><span class="comment">//must be 0x55aa</span></span><br><span class="line"><span class="comment">//use db or dw can complete it</span></span><br><span class="line">db <span class="number">0x55</span>,<span class="number">0xaa</span></span><br><span class="line">dw <span class="number">0xaa55</span>      <span class="comment">//cause,write a word into memory with low byte alignment</span></span><br></pre></td></tr></table></figure>



<h3 id="div-process-unsigned-number"><a href="#div-process-unsigned-number" class="headerlink" title="div(process unsigned number)"></a>div(process unsigned number)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// div has two different methods to use</span></span><br><span class="line"><span class="comment">// div followed by regiseter or memoryaddress </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// No1: 16-bit dividend is divided by 8-bit divisor</span></span><br><span class="line"><span class="comment">//the 16-bit dividend need loading into ax</span></span><br><span class="line"><span class="comment">//quotient in al , remainder in ah</span></span><br><span class="line">div cl</span><br><span class="line">div <span class="keyword">byte</span> [<span class="number">0x0023</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// No2: 32-bit dividend is divided by 16</span></span><br><span class="line"><span class="comment">// under this situation, divident can't be placed in ax</span></span><br><span class="line"><span class="comment">//so,it's divided two parts, the hightest 16 bit is placed in dx</span></span><br><span class="line"><span class="comment">// the lowest 16 bit is placed in ax</span></span><br><span class="line"><span class="comment">// then,quotient in ax , remainder in dx</span></span><br><span class="line">div cx</span><br><span class="line">div <span class="keyword">word</span> [<span class="number">0x0230</span>]</span><br></pre></td></tr></table></figure>



<h3 id="mul"><a href="#mul" class="headerlink" title="mul"></a>mul</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//It makes the value contained in parameter multiply al or ax.Bit width should be identical. If al ,put result into ax, while if ax , put result into dx:ax</span></span><br><span class="line"><span class="comment">//parameter can be regs or memaddr</span></span><br><span class="line">mul bx</span><br><span class="line">mul <span class="keyword">word</span> [<span class="number">0x2000</span>]</span><br></pre></td></tr></table></figure>





<h3 id="idiv-process-signed-number"><a href="#idiv-process-signed-number" class="headerlink" title="idiv(process signed number)"></a>idiv(process signed number)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//when caculating signed number division, especially 32 bit dividend, dx's value need noting</span></span><br><span class="line"><span class="keyword">xor</span> dx,dx</span><br><span class="line">mov ax,<span class="number">0xf0c0</span></span><br><span class="line">mov bx,<span class="number">0x10</span></span><br><span class="line">idiv bl</span><br><span class="line"><span class="comment">//WRONG!dx:ax=0000 f0c0,dx:ax is a positive number</span></span><br><span class="line"><span class="comment">//Correct way</span></span><br><span class="line">mov ax,<span class="number">0xf0c0</span></span><br><span class="line">cwd</span><br><span class="line">mov bx,<span class="number">0x10</span></span><br><span class="line">idiv bl</span><br></pre></td></tr></table></figure>





<h3 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//xor has two parameters, the first of which should be register or memAddress</span></span><br><span class="line"><span class="comment">//the second of which could be register , memAddress or immediate.</span></span><br><span class="line"><span class="comment">//But they couldn't be immediate or memAddress at the same time.</span></span><br><span class="line"><span class="comment">//Both of parameters have the same bit width.</span></span><br><span class="line"><span class="keyword">xor</span> <span class="keyword">word</span> [<span class="number">0x2002</span>], <span class="number">0x55aa</span></span><br></pre></td></tr></table></figure>



<h3 id="infinite-loop"><a href="#infinite-loop" class="headerlink" title="infinite loop"></a>infinite loop</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">infi: jmp near infi</span><br></pre></td></tr></table></figure>



<h3 id="times-pseudo"><a href="#times-pseudo" class="headerlink" title="times (pseudo)"></a>times (pseudo)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//this pseudoinstruction repeat its following instructions with many times</span></span><br><span class="line">times <span class="number">20</span> mov ax,bx</span><br><span class="line">times <span class="number">203</span> db <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h3 id="line-continuation"><a href="#line-continuation" class="headerlink" title="/ : line continuation"></a>/ : line continuation</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In NASM, '\' is line continuation. When a single line can't contain all codes, '\' is put in line rear, which indicates this line and the next line shouble be conbined into a line.</span></span><br><span class="line"></span><br><span class="line">mytext: db <span class="string">'L'</span>,<span class="number">0x07</span>,<span class="string">'b'</span>,<span class="number">0x07</span>,<span class="string">'a'</span>,<span class="number">0x07</span>,<span class="string">'e'</span>,<span class="number">0x07</span>,<span class="string">'l'</span>,<span class="number">0x07</span>,<span class="string">' '</span>,<span class="number">0x07</span>,<span class="string">'o'</span>,<span class="number">0x07</span>,\</span><br><span class="line">    		<span class="string">'f'</span>,<span class="number">0x07</span>,<span class="string">'f'</span>,<span class="number">0x07</span>,<span class="string">'s'</span>,<span class="number">0x07</span>,<span class="string">'e'</span>,<span class="number">0x07</span>,<span class="string">'t'</span>,<span class="number">0x07</span>,<span class="string">':'</span>,<span class="number">0x07</span></span><br></pre></td></tr></table></figure>



<h3 id="movsw-movsb-cld-clear-direction-flag-std-set-direction-flag-rep"><a href="#movsw-movsb-cld-clear-direction-flag-std-set-direction-flag-rep" class="headerlink" title="movsw,movsb,cld(clear direction flag),std(set direction flag),rep"></a>movsw,movsb,cld(clear direction flag),std(set direction flag),rep</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Both of them can make bulk transfer from one memory address to another address. movsw transfers a word once while movsb delivers a byte at a time. The destination, starting point and times of transfer depend on ES:DI, DS:SI and CX</span></span><br><span class="line"></span><br><span class="line">mov ax,<span class="number">0x7c0</span></span><br><span class="line">mov ds,ax</span><br><span class="line">    </span><br><span class="line">mov ax,<span class="number">0xb800</span></span><br><span class="line">mov es,ax</span><br><span class="line"></span><br><span class="line">cld             <span class="comment">//this instruction is to set FLAGS(register)to indicate 					        //transfer</span></span><br><span class="line">    			<span class="comment">// direction, from low binary to high binary or the opposite</span></span><br><span class="line">    			<span class="comment">// cld sets the tenth bit-direction flag to 0 (positive)</span></span><br><span class="line">    			<span class="comment">//while std have the opposite function</span></span><br><span class="line">mov si,mytext</span><br><span class="line">mov di,<span class="number">0</span></span><br><span class="line">mov cx,(number-mytext)/<span class="number">2</span></span><br><span class="line">rep movsw       <span class="comment">//rep is a instruction instruction prefix, its following 						instruction continue working until cx decreases to 0.</span></span><br><span class="line"><span class="comment">//<span class="doctag">NOTE:</span>after movsw, the value of di has been changed, pointing out the empty positioni.</span></span><br></pre></td></tr></table></figure>



<h3 id="lodsb-lodsw"><a href="#lodsb-lodsw" class="headerlink" title="lodsb,lodsw*"></a>lodsb,lodsw*</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">lodsb or lodsw transfer a byte or a word into al or ax in accordance with the positioin of DS:SI and then increase or decrease SI according to DF(direction flag).</span><br></pre></td></tr></table></figure>



<h3 id="stosb-stosw-stosd"><a href="#stosb-stosw-stosd" class="headerlink" title="stosb, stosw, stosd"></a>stosb, stosw, stosd</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">b-&gt;byte</span><br><span class="line">w-&gt;word</span><br><span class="line">d-&gt;double word</span><br><span class="line">transfer eax(byte, word or dword) to es:edi</span><br><span class="line">then increase or decrease di according to DF</span><br></pre></td></tr></table></figure>





<h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Two steps it will make:</span></span><br><span class="line"><span class="comment">//the first is to descrease cx by one;</span></span><br><span class="line"><span class="comment">//the other is checking out wheter to continue loop on the value of cx.</span></span><br><span class="line">loop label</span><br></pre></td></tr></table></figure>



<h3 id><a href="#" class="headerlink" title="$"></a>$</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//$ is label offered by NASM. It represents the offset of current line.</span></span><br><span class="line">jmp near $   <span class="comment">// equal to infi: jmp near infi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//$$ represents the assembly address of current assembly segment.</span></span><br><span class="line">times <span class="number">510</span>-($-$$) db <span class="number">0</span></span><br><span class="line">db <span class="number">0x55</span>,<span class="number">0xaa</span></span><br><span class="line"><span class="comment">//the two line can fill master boot sector so that the last two binary can be recognized as the flag of master boot sector.</span></span><br></pre></td></tr></table></figure>



<h3 id="neg-negative"><a href="#neg-negative" class="headerlink" title="neg(negative)"></a>neg(negative)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//neg is used to convert a number to its opposite</span></span><br><span class="line"><span class="comment">//al=8</span></span><br><span class="line">neg al  <span class="comment">// al=-8</span></span><br></pre></td></tr></table></figure>

<h3 id="cbw-Convert-Byte-to-Word-cwd-Convert-Word-to-Double-Word"><a href="#cbw-Convert-Byte-to-Word-cwd-Convert-Word-to-Double-Word" class="headerlink" title="cbw(Convert Byte to Word),cwd(Convert Word to Double-Word)"></a>cbw(Convert Byte to Word),cwd(Convert Word to Double-Word)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cbw will extend a signed number in al into ax while cwd extend a signed number in ax into dx:ax. Actually, it just fills ah or dx with signed bit of al or ax</span></span><br><span class="line"><span class="comment">//<span class="doctag">NOTE:</span> cbw and cwd don't have operand with implicit operand-al or ax.</span></span><br><span class="line">cbw</span><br><span class="line">cwd</span><br></pre></td></tr></table></figure>



<h3 id="jns-js"><a href="#jns-js" class="headerlink" title="jns , js"></a>jns , js</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jns is a conditional branch instruction based on SF(sign flag) of FLAGS(flag register). </span></span><br><span class="line"><span class="comment">//Many arithmetic and logical instruction can sway SF, such as add, sub, xor and so on. When the highest bit of a result outputted by A&amp;L instruction is 1, CPU will set SF to 1, while set 0 under the other situation.</span></span><br><span class="line"><span class="comment">// SF=0, jns vaild, tranferring</span></span><br><span class="line"><span class="comment">//ZF(zero flag) be set when result is 0</span></span><br><span class="line">dec si</span><br><span class="line">jns show</span><br></pre></td></tr></table></figure>



<h3 id="jo-jno-jc-jnc-jp-jnp"><a href="#jo-jno-jc-jnc-jp-jnp" class="headerlink" title="jo,jno,jc,jnc,jp,jnp"></a>jo,jno,jc,jnc,jp,jnp</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// all of them similar to jns and js</span></span><br></pre></td></tr></table></figure>



<h3 id="jcxz-jump-if-cx-is-zero"><a href="#jcxz-jump-if-cx-is-zero" class="headerlink" title="jcxz (jump if cx is zero)"></a>jcxz (jump if cx is zero)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>



<h3 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//compare two operands, not keep result but set flag bit in accordace with result</span></span><br><span class="line">cmp al,<span class="number">0x08</span> equal to sub al,<span class="number">0x08</span> <span class="comment">//but dont keep value into al</span></span><br><span class="line">cmp ax,bx</span><br><span class="line"><span class="comment">//ax is the hero. We do care about if ax &gt; bx, if ax &lt; bx or if ax = bx.</span></span><br><span class="line"><span class="comment">//bx is a baseline.</span></span><br></pre></td></tr></table></figure>



<h3 id="push-pop"><a href="#push-pop" class="headerlink" title="push,pop"></a>push,pop</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//push and pop used for munipulating stack(in memory)</span></span><br><span class="line"><span class="comment">//There are two steps to define a stack segment:</span></span><br><span class="line"><span class="comment">//mov ss,ax ;ax=0</span></span><br><span class="line"><span class="comment">//mov sp,ax</span></span><br><span class="line"><span class="comment">//Both of two instructions just manipulate 16-bit register or  memory unit, with 8-bit register impossible</span></span><br><span class="line"><span class="comment">//working mechanism:</span></span><br><span class="line"><span class="comment">//In spite of defining in 0x00000, push stores value after decreasing sp by 2,so, stack grows from top to down-from FFFF0 to 00000.</span></span><br><span class="line"><span class="comment">//Because master boot sector is loaded in 0x07c00, stack should be paied attention not to grow into MBS'area, which programmers should control carefully.</span></span><br></pre></td></tr></table></figure>



<h3 id="push-in-32-mode"><a href="#push-in-32-mode" class="headerlink" title="push (in 32 mode)"></a>push (in 32 mode)</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">In 16 mode, push cant have immediate operand, while 32 mode dose.</span><br><span class="line"></span><br><span class="line">push byte 0x55</span><br><span class="line">Whatever in 16 mode or 32 mode, pushing in stack will never be byte 0x55. In 16 mode, 0x0055 is pushed ,while in 32 mode, 0x00000055 is pushed. These work is what compiler dose and transparent to programmer.</span><br><span class="line">Although under 32 mode 8-bit immi can be pushed, when it is poped, it couldn't pop to 8-bit register, while into 32-bit register.</span><br><span class="line"></span><br><span class="line">;under 32-bit mode </span><br><span class="line">push byt '.'</span><br><span class="line">pop eax      ;correct</span><br></pre></td></tr></table></figure>





<h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//8086 supports four calling ways</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1:Relative near calling: parameters offered by label. It just can call procedure in the same segment.</span></span><br><span class="line">call near proc_1 <span class="comment">//near is dispensable.Without near. compiler deems near call.</span></span><br><span class="line">call <span class="number">0x0500</span>      <span class="comment">//different from indirect absolute near calling</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2:Indirect absolute near calling: parameter offered by regs or mem</span></span><br><span class="line">call cx</span><br><span class="line">call [<span class="number">0x3000</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//3:Direct absolute far calling: parameter offered by two parts, the first of which is offset while the other is segement base address. It can call procedure from inter-segment.</span></span><br><span class="line">call <span class="number">0x2000</span>:<span class="number">0x0030</span>   <span class="comment">//0x2000 is offset ,0x0030 is base address</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.Indirect absolute far calling, keyword far is necessary.parameter offered by regs or mem.</span></span><br><span class="line">call far [bx]</span><br><span class="line">call far [proc_1]  ;proc_1 dw <span class="number">0x0102</span>,<span class="number">0x2000</span> <span class="comment">//0x0102 offset  0x2000 base add</span></span><br></pre></td></tr></table></figure>



<h3 id="jmp-unconditional"><a href="#jmp-unconditional" class="headerlink" title="jmp (unconditional)"></a>jmp (unconditional)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//five different ways</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1: relative short jmp: jump range is 8-bit length</span></span><br><span class="line">jmp short infinite   <span class="comment">//short is necessary</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2: 16-bit relative near jump: jump range is 16-bit length</span></span><br><span class="line">jmp near infinite   <span class="comment">//near can be removed, compiler generates machine code </span></span><br><span class="line">    				<span class="comment">//with regard to jmp's length of parameter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3: 16-bit indirect absolute jump: its parameter is regs or memAddr which offers real offset that needn't caculating by compiler,which means the offset will be sent to IP directly </span></span><br><span class="line"> jmp near bx</span><br><span class="line"> jmp [jump_dest]  <span class="comment">//jump_dest dw 0xc000</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//4: 16-bit direct absolute far jump:</span></span><br><span class="line">    jmp <span class="number">0x0000</span>:<span class="number">0x7c00</span> <span class="comment">//0x0000 base addr put in CS directly, 0x7c00 offset</span></span><br><span class="line">        			  <span class="comment">// put in IP directly</span></span><br><span class="line"><span class="comment">//5: 16-bit indirect absolute far jump: access to memory to get segment basic address and intro-segment offset, not register.</span></span><br><span class="line">	jump_far dw <span class="number">0x33c0</span>,<span class="number">0xf000</span> <span class="comment">//0x33c0 offset 0xf000 basic addr</span></span><br><span class="line">    jmp far [jump_far]        <span class="comment">// far is indispensable</span></span><br></pre></td></tr></table></figure>



<h3 id="ret-retf"><a href="#ret-retf" class="headerlink" title="ret,retf"></a>ret,retf</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ret is near return while retf is far return</span></span><br><span class="line"><span class="comment">//when executing ret, stack will pop a 16-bit operand to IP</span></span><br><span class="line"><span class="comment">//but when retf, stack will pop two words into CS and IP</span></span><br><span class="line"><span class="comment">//<span class="doctag">NOTE:</span> So-called stack is just current segment's stack which can be accessed by sp and ss</span></span><br><span class="line">ret</span><br><span class="line">retf</span><br><span class="line"><span class="comment">// for retf, the fisrt pop is ip the second is cs</span></span><br></pre></td></tr></table></figure>



<h3 id="cli-sti"><a href="#cli-sti" class="headerlink" title="cli, sti"></a>cli, sti</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">cli: clear interrupt flag will ignore interrupt</span><br><span class="line">sti: set interrupt flag  will open interrupt</span><br><span class="line">Both of them change IF in FLAG register</span><br></pre></td></tr></table></figure>



<h3 id="hlt-halt"><a href="#hlt-halt" class="headerlink" title="hlt(halt)"></a>hlt(halt)</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">no operand, let computer stay in halt situation and low power state</span><br></pre></td></tr></table></figure>



<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">.w0:</span><br><span class="line"><span class="code">	mov al,0x0a</span></span><br><span class="line"><span class="code">	or al,0x80</span></span><br><span class="line"><span class="code">	out 0x70,al</span></span><br><span class="line"><span class="code">	in al,0x71</span></span><br><span class="line"><span class="code">	test al,0x80</span></span><br><span class="line"><span class="code">	jnz .w0</span></span><br><span class="line">If the seventh bit of al is 1, then jump to .w0. otherwise,execute sequentially.</span><br><span class="line">test actually is similar to 'and' ,set FLAG according result but discard it.</span><br></pre></td></tr></table></figure>



<h3 id="bits-16-bits-32"><a href="#bits-16-bits-32" class="headerlink" title="[bits 16], [bits 32]"></a>[bits 16], [bits 32]</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[bits 16]  [bits 32] are pseudoinstruction, which indicate default compiling mode. [] is dispensible.</span><br></pre></td></tr></table></figure>



<h3 id="org"><a href="#org" class="headerlink" title="org **"></a>org **</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">org makes label assembly offset plus org's argument.</span><br><span class="line">Without org, label represents offset relative to segment or programm start.</span><br><span class="line">While with org, such as org 0x7c00, every offset label represents will be added by 0x7c00.</span><br></pre></td></tr></table></figure>



<h3 id="rep"><a href="#rep" class="headerlink" title="%rep"></a>%rep</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">pre-instruction:</span><br><span class="line">%rep 255</span><br><span class="line"><span class="code">	Gate SelectorCode 32, SpuriousHandler , 0 , DA_386_IGate</span></span><br><span class="line">%endrep</span><br></pre></td></tr></table></figure>





<h3 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips 1"></a>Tips 1</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//If you want to use register to offer offset, there are just a few registers capable,which are BX,SI,DI,SP. It is a hardware rule.</span></span><br><span class="line"><span class="comment">//Besides, instruction mov ax,[bx] is actually equal to mov ax,[ds:bx] while you can appoint segment explicitly, such as mov ax,[es:bx]</span></span><br></pre></td></tr></table></figure>

<h3 id="Tips-2"><a href="#Tips-2" class="headerlink" title="Tips 2"></a>Tips 2</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Segment reigsters, like ss,cs,ds and es, can't be operand of arithmetic and logical instructions.</span></span><br><span class="line"><span class="keyword">xor</span> ss,ss</span><br><span class="line">add cs,cs <span class="comment">// both wrong</span></span><br></pre></td></tr></table></figure>



<h3 id="Tips-3"><a href="#Tips-3" class="headerlink" title="Tips 3"></a>Tips 3</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">Logical segment like header,code,data,stack ,is declared with vstart=0.</span><br><span class="line">So that,we just need to get this segment base address and then can obtain data there by intro-segment offset.</span><br></pre></td></tr></table></figure>



<h3 id="Tips-4"><a href="#Tips-4" class="headerlink" title="Tips 4"></a>Tips 4</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">When changing the value of ss, cpu will disable interrupt within this instruction and the next instruction. The next instrction is usually to change  the value of sp. Disabling interrupt has significance. Imagine that after finishing the change of the value of ss, an interrupt occurs so that the relevant register in current segment must be pushed into stack. However the ss has changed. push into a fault position.</span><br></pre></td></tr></table></figure>



<h3 id="Tips-5"><a href="#Tips-5" class="headerlink" title="Tips 5"></a>Tips 5</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Under 32 protected mode, we can point out effective address by using general register (EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI) plus general registers other than ESP, the latter part can multiply a factor (1,2,4,8), and then can add a offset</span><br><span class="line"></span><br><span class="line">mov ecx,[eax+ebx*8+0x02]</span><br></pre></td></tr></table></figure>



<h3 id="Tips-6"><a href="#Tips-6" class="headerlink" title="Tips 6"></a>Tips 6</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">After finishing global descriptor table, there are some tasks to do for into protect mode.</span><br><span class="line">1: resolve historical issue, open A20</span><br><span class="line"></span><br><span class="line">in al,0x92</span><br><span class="line">or al,0000_0010B</span><br><span class="line">out 0x92,al</span><br><span class="line"> </span><br><span class="line">2: IVT in real mode isn't situable. switch off interrupt</span><br><span class="line"></span><br><span class="line">cli</span><br><span class="line"></span><br><span class="line">3:cr0 (control register):  save flags for controling CPU mode and running situation. The zero bit is Protection Enable. 1 :into protect mode.</span><br><span class="line"></span><br><span class="line">mov eax,cr0</span><br><span class="line">or eax,1</span><br><span class="line">mov cro,eax</span><br><span class="line"></span><br><span class="line">4:from real mode into protect mode</span><br><span class="line"></span><br><span class="line">jmp dword 0x0008:flush   ;0x0008 is selector while flush is 32-bit offset</span><br><span class="line"></span><br><span class="line">NOTE: dword is to embellish offset and has nothing to do with selector.</span><br></pre></td></tr></table></figure>



<h3 id="Tips-7"><a href="#Tips-7" class="headerlink" title="Tips 7"></a>Tips 7</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">To be compatible with 16-bit real mode, in 16-bit real mode, segment liner base address in descriptor high-speed buffer validate the low 20 bits, while the high 16 bit is invalid.</span><br></pre></td></tr></table></figure>



<h3 id="Tips-8"><a href="#Tips-8" class="headerlink" title="Tips 8"></a>Tips 8</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">With regard to master boot sector, when it is loaded into memory address 0x7c00, whether to use pseudo-instruction org 0x7c00, initially, cs is 0x0000 and ip is 0x7c00.</span><br></pre></td></tr></table></figure>



<h3 id="Tips-9"><a href="#Tips-9" class="headerlink" title="Tips 9"></a>Tips 9</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">If a label starts with dot(.), it's a local label and must follow after global label.</span><br></pre></td></tr></table></figure>



<h3 id="Tips-10"><a href="#Tips-10" class="headerlink" title="Tips 10"></a>Tips 10</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Programm habits:      </span><br><span class="line"></span><br><span class="line">LABEL<span class="emphasis">_SEG_</span>CODE32:</span><br><span class="line"><span class="code">	...</span></span><br><span class="line">SegCode32Len  equ $-LABEL<span class="emphasis">_SEG_</span>CODE32</span><br><span class="line"></span><br><span class="line">SegCode32Len: These len label is to set segment limit conveniently</span><br></pre></td></tr></table></figure>



<h3 id="Tips-11"><a href="#Tips-11" class="headerlink" title="Tips 11*"></a>Tips 11*</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Under real mode, label could be offset relative to the start of programm or segment. However, under protect mode, label must represent offset relative to segment start.</span><br></pre></td></tr></table></figure>





<h3 id="Addressing-Mode"><a href="#Addressing-Mode" class="headerlink" title="Addressing Mode"></a>Addressing Mode</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Four modes to address:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. Register Addressing</span></span><br><span class="line">mov ax,cx</span><br><span class="line">inc dx</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. Immediate Addressing</span></span><br><span class="line">mov bx,<span class="number">0xf000</span></span><br><span class="line">mov dx,label_a</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. Memory Addressing</span></span><br><span class="line"><span class="comment">//3.1 Direct Addressing</span></span><br><span class="line">mov ax,[<span class="number">0x5c0f</span>]</span><br><span class="line">add <span class="keyword">word</span> [<span class="number">0x0230</span>],<span class="number">0x5000</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//3.2 Base Addressing</span></span><br><span class="line"><span class="comment">//base register:bx bp -offer offset</span></span><br><span class="line">mov [bx],dx</span><br><span class="line">add <span class="keyword">byte</span> [bx],<span class="number">0x55</span></span><br><span class="line">mov [bx+<span class="number">0x100</span>],al</span><br><span class="line">    </span><br><span class="line"><span class="comment">//3.3 Indexed Addressing</span></span><br><span class="line"><span class="comment">//indexed register:si di -offer offset</span></span><br><span class="line">mov [si],dx</span><br><span class="line">add ax,[di]</span><br><span class="line">mov [si+<span class="number">0x100</span>],al</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.4 Base Indexed Addressing</span></span><br><span class="line">add <span class="keyword">word</span> [bx+di],<span class="number">0x3000</span></span><br></pre></td></tr></table></figure>



<h3 id="Manipulate-disk-to-read-data"><a href="#Manipulate-disk-to-read-data" class="headerlink" title="Manipulate disk to read data"></a>Manipulate disk to read data</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CPU accesses disk by manipulate I/O ports that are addressed independent to memory address. A I/O port actually is a 8-bit or 16-bit register.</span></span><br><span class="line"><span class="comment">//All ports are unified addressing, from 0x0001 to 0xffff. Every I/O interface is assigned some ports. </span></span><br><span class="line"><span class="comment">//0x1f0-0x1f7 are assigned master hard disk interface</span></span><br><span class="line"><span class="comment">//while slave hard disk with 0x170-0x177</span></span><br><span class="line"><span class="comment">//0x1f0: data port</span></span><br><span class="line"><span class="comment">//0x1f1: fault information port</span></span><br><span class="line"><span class="comment">//0x1f2: indicate how many sectors to read</span></span><br><span class="line"><span class="comment">//0x1f3-0x1f6: save 24-bit LBA address,the high four bits of 0x1f6 have extra meaning,which don't indicate location.</span></span><br><span class="line"><span class="comment">//0x1f6: the seveth and the fifths bit are 1. The sixth bit: 0 CHS  1 LBA</span></span><br><span class="line"><span class="comment">//the fourth bit: 0 master disk  1 slave disk</span></span><br><span class="line"><span class="comment">//0x1f7: command and situation port. 0x20 is reading command.</span></span><br><span class="line"><span class="comment">//About 0x1f7: the seveth bit means whether busy,the third bit means whether to be ready to exchange with cpu. CPU can read this port frequently, if it is 0x08 , that means hard disk gets ready to exchange data with cpu. While if it's the highest bit is 1, it can't transfer data.</span></span><br><span class="line"><span class="comment">//Instruction format: in  out :dx save port number , ax or al save data</span></span><br><span class="line">in al,dx</span><br><span class="line">in ax,dx</span><br><span class="line"></span><br><span class="line">out dx,al</span><br><span class="line">out dx,ax</span><br><span class="line"></span><br><span class="line">out <span class="number">0x37</span>,al <span class="comment">//;this is possible but impossible in in</span></span><br></pre></td></tr></table></figure>



<h3 id="Control-cursor-by-modifying-ports-in-video-card"><a href="#Control-cursor-by-modifying-ports-in-video-card" class="headerlink" title="Control cursor by modifying ports in video card"></a>Control cursor by modifying ports in video card</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Since video card have many ports, we don't manipulate port as I/O interface, which means we dont write target port number into dx to point out which to operate. Pointing out target register by index register-0x3d4. While cursor position is kept in port 0x0e and 0x0f.</span></span><br><span class="line"><span class="comment">//0x0e: high 8 bit , 0x0f: low 8 bit. data port: 0x3d5</span></span><br><span class="line">;<span class="built_in">get</span> <span class="built_in">position</span> of current <span class="built_in">cursor</span></span><br><span class="line">mov dx,<span class="number">0x3d4</span></span><br><span class="line">mov al,<span class="number">0x0e</span></span><br><span class="line">out dx,al</span><br><span class="line">mov dx,<span class="number">0x3d5</span></span><br><span class="line">in al,dx</span><br><span class="line">mov ah,al</span><br><span class="line"></span><br><span class="line">mov dx,<span class="number">0x3d4</span></span><br><span class="line">mov al,<span class="number">0x0f</span></span><br><span class="line">out dx,al</span><br><span class="line">mov dx,<span class="number">0x3d5</span></span><br><span class="line">in al,dx</span><br></pre></td></tr></table></figure>



<h3 id="User-program-basic-framework"><a href="#User-program-basic-framework" class="headerlink" title="User program basic framework"></a>User program basic framework</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//when cpu jumps from loader to usr program, ds and es point out user program header segment basic address</span></span><br><span class="line"></span><br><span class="line">SECTION header vstart=<span class="number">0</span></span><br><span class="line">   	program_length: dd program_end</span><br><span class="line">   	code_entry:    dw start</span><br><span class="line">   				   dd section.code_1.start</span><br><span class="line">    realloc_tb1_len: dw (header_end-code_1_segment)/<span class="number">4</span></span><br><span class="line">    </span><br><span class="line">     code_1_segment: dd section.code_1.start</span><br><span class="line">     code_2_segment: dd section.code_2.start</span><br><span class="line">     data_1_segment: dd section.data_1.start</span><br><span class="line">     data_2_segment: dd section.data_2.start</span><br><span class="line">header_end:</span><br><span class="line"></span><br><span class="line">SECTION code_1 align=<span class="number">16</span> vstart=<span class="number">0</span></span><br><span class="line">	start:           <span class="comment">//this label is for jumping here easily</span></span><br><span class="line">		<span class="comment">//valid codes</span></span><br><span class="line">	</span><br><span class="line">SECTION code_2 align=<span class="number">16</span> vstart=<span class="number">0</span></span><br><span class="line">    <span class="built_in">begin</span>:			 <span class="comment">//this label is for jump here easily</span></span><br><span class="line"></span><br><span class="line">SECTION data_1 align=<span class="number">16</span> vstart=<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">SECTION data_2 align=<span class="number">16</span> vstart=<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">SECTION <span class="built_in">stack</span> align=<span class="number">16</span> vstart=<span class="number">0</span></span><br><span class="line">    resb <span class="number">256</span>      <span class="comment">//declare stack space, can change</span></span><br><span class="line">stack_end:        <span class="comment">//this label is put into sp.</span></span><br><span class="line"></span><br><span class="line">SECTION trail align=<span class="number">16</span></span><br><span class="line">program_end:      <span class="comment">//this label is for caculating program length.</span></span><br></pre></td></tr></table></figure>



<h3 id="BCD-code-Binary-coded-Decimal"><a href="#BCD-code-Binary-coded-Decimal" class="headerlink" title="BCD  code (Binary coded Decimal)"></a>BCD  code (Binary coded Decimal)</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">For a decimal number 25, its normal binary format is 00011001</span><br><span class="line">but the BCD format changes 2 and 5 to binary respectively, which is 00100101.</span><br><span class="line">Obviously, four bit represent up to 15, but decimal up to 9, so more than 1001 impossible</span><br></pre></td></tr></table></figure>



<h3 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1: Interrupt is sent into CPU with two leads which are NMI(NOn Maskable Interrupt, NMI) and INTR(Maskable Interrupt)</span><br><span class="line"></span><br><span class="line">2:8259 programmable Interrupt Controller (PIC) can be set sitation and interrupt number in every lead. There are two chips in every PC.</span><br><span class="line"></span><br><span class="line">3:8259 contains Interrupt Mask Register(IMR), a 8-bit register which corresponds eight leads, deciding whether the interrupt is vaild, 0: INTR avalible 1: INTR unavabilable</span><br><span class="line">Master port: 0x20 0x21   Slave port: 0xa0 0xa1 </span><br><span class="line"></span><br><span class="line">Example: read IMR from in 0xa1 in slave</span><br><span class="line">in al,0xa1	 // read before write</span><br><span class="line">and al,0xfe  // lead 0 allows interrupt from RTC</span><br><span class="line">out 0xa1,al  //underlying information:0xa1 saves IMR</span><br><span class="line"></span><br><span class="line">4:Lead IR0 has the highest priority, while Lead IR7 has the lowest priority. Every lead has a Interrpt number which is programmable by the whole chip.</span><br><span class="line"></span><br><span class="line">5:8259 controller has a Interrupt Service Register(ISR), 8 bit, its every bit correspond to an interrupt lead. When processing interrupt, 8259 will set corresponding bit 1 indicating doing serevice for the interrupt from this lead</span><br></pre></td></tr></table></figure>



<h3 id="IVT-Interrupt-Vector-Table"><a href="#IVT-Interrupt-Vector-Table" class="headerlink" title="IVT(Interrupt Vector Table)"></a>IVT(Interrupt Vector Table)</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">IVT is put within 00000-003ff, including up to 256 interrupt service program,</span><br><span class="line">After 8256 sends interrupt number to CPU, CPU will get the entry of interrupt service programm according to interrupt number.</span><br></pre></td></tr></table></figure>



<h3 id="CMOS-RAM-inside-RTC-Real-Time-Clock"><a href="#CMOS-RAM-inside-RTC-Real-Time-Clock" class="headerlink" title="CMOS RAM inside RTC(Real-Time Clock)"></a>CMOS RAM inside RTC(Real-Time Clock)</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">0x70 , 0x74 indexed port</span><br><span class="line">0x71 , 0x75 data port</span><br><span class="line"></span><br><span class="line">Example: obtain week</span><br><span class="line">mov al,0x06   ; the 0x06 byte keeps what week</span><br><span class="line">out 0x70,al</span><br><span class="line">in al,0x71</span><br></pre></td></tr></table></figure>



<h3 id="8086-Memory-Layout"><a href="#8086-Memory-Layout" class="headerlink" title="8086 Memory Layout"></a>8086 Memory Layout</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1:  0x00000 ~ 0x003ff   :Interrupt vector table 1024B</span><br><span class="line">2:  0x00400 ~ 0x004ff   :BIOS data area            256B</span><br><span class="line">3:  0x00500 ~ 0x07bff   :Free area                 1280B</span><br><span class="line">4:  0x07c00 ~ 0x07dff   :Boot sector entry         512B</span><br><span class="line">5:  0x07e00 ~ 0x9ffff   :Free area                 32256B</span><br><span class="line">6:  0xa0000 ~ 0xaffff   :Graph and video buffer    64KB</span><br><span class="line">7:  0xb0000 ~ 0xb7fff   :mono text video buffer    32KB</span><br><span class="line">8:  0xb8000 ~ 0xbffff   :chroma text video buffer  32KB</span><br><span class="line">9:  0xc0000 ~ 0xc7fff   :video card bios           32KB</span><br><span class="line">10: 0xc8000 ~ 0xcbfff   :IDE controller BISO       16KB</span><br><span class="line">11: 0xcc000 ~ 0xeffff                              143KB</span><br><span class="line">12: 0xf0000 ~ 0xfffff   :system BIOS               64KBs</span><br></pre></td></tr></table></figure>



<h3 id="Real-mode-into-Protect-mode-reference-code"><a href="#Real-mode-into-Protect-mode-reference-code" class="headerlink" title="Real mode into Protect mode reference code"></a>Real mode into Protect mode reference code</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SECTION mbr align=<span class="number">16</span> vstart=<span class="number">0x7c00</span></span><br><span class="line">   [bits <span class="number">16</span>]</span><br><span class="line">	mov ax,cs</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov sp,<span class="number">0x7c00</span></span><br><span class="line"></span><br><span class="line">	mov ax,[cs:gdt_base]</span><br><span class="line">	mov dx,[cs:gdt_base+<span class="number">0x02</span>]</span><br><span class="line">	mov bx,<span class="number">16</span></span><br><span class="line">	div bx</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx,dx</span><br><span class="line"></span><br><span class="line">	mov dword [bx],<span class="number">0x00000000</span></span><br><span class="line">	mov dword [bx+<span class="number">0x04</span>],<span class="number">0x00000000</span></span><br><span class="line"></span><br><span class="line">	mov dword [bx+<span class="number">0x08</span>],<span class="number">0x7c0001ff</span></span><br><span class="line">	mov dword [bx+<span class="number">0x0c</span>],<span class="number">0x00409800</span></span><br><span class="line"></span><br><span class="line">	mov dword [bx+<span class="number">0x10</span>],<span class="number">0x8000ffff</span></span><br><span class="line">	mov dword [bx+<span class="number">0x14</span>],<span class="number">0x0040920b</span></span><br><span class="line"></span><br><span class="line">	mov dword [bx+<span class="number">0x18</span>],<span class="number">0x00007a00</span></span><br><span class="line">	mov dword [bx+<span class="number">0x1c</span>],<span class="number">0x00409600</span></span><br><span class="line">	mov <span class="keyword">word</span> [cs:gdt_size],<span class="number">31</span></span><br><span class="line"></span><br><span class="line">	lgdt [cs:gdt_size]     ;load gdt <span class="keyword">register</span> <span class="number">48</span> <span class="built_in">bit</span></span><br><span class="line"></span><br><span class="line">	;<span class="built_in">connect</span> A20</span><br><span class="line">	in al,<span class="number">0x92</span></span><br><span class="line">	<span class="keyword">or</span> al,<span class="number">0000</span>_0010B</span><br><span class="line">	out <span class="number">0x92</span>,al</span><br><span class="line"></span><br><span class="line">	cli</span><br><span class="line"></span><br><span class="line">	mov eax,cr0</span><br><span class="line">	<span class="keyword">or</span> eax,<span class="number">1</span></span><br><span class="line">	mov cr0,eax</span><br><span class="line"></span><br><span class="line">	jmp dword <span class="number">0x0008</span>:<span class="built_in">flush</span><span class="number">-0x7c00</span></span><br><span class="line"></span><br><span class="line">	[bits <span class="number">32</span>]</span><br><span class="line"> <span class="built_in">flush</span>:</span><br><span class="line">	mov  cx,<span class="number">00000000000</span>_10_000B</span><br><span class="line">	mov ds,cx</span><br><span class="line">	mov <span class="keyword">byte</span> [<span class="number">0x00</span>],<span class="string">'P'</span></span><br><span class="line">	mov <span class="keyword">byte</span> [<span class="number">0x02</span>],<span class="string">'r'</span></span><br><span class="line">	mov <span class="keyword">byte</span> [<span class="number">0x04</span>],<span class="string">'o'</span></span><br><span class="line">	mov <span class="keyword">byte</span> [<span class="number">0x06</span>],<span class="string">'t'</span></span><br><span class="line">	mov <span class="keyword">byte</span> [<span class="number">0x08</span>],<span class="string">'e'</span></span><br><span class="line">	mov <span class="keyword">byte</span> [<span class="number">0x0a</span>],<span class="string">'c'</span></span><br><span class="line">	mov <span class="keyword">byte</span> [<span class="number">0x0c</span>],<span class="string">'t'</span></span><br><span class="line">	mov <span class="keyword">byte</span> [<span class="number">0x0e</span>],<span class="string">'m'</span></span><br><span class="line">	mov <span class="keyword">byte</span> [<span class="number">0x10</span>],<span class="string">'o'</span></span><br><span class="line">	mov <span class="keyword">byte</span> [<span class="number">0x12</span>],<span class="string">'d'</span></span><br><span class="line">	mov <span class="keyword">byte</span> [<span class="number">0x14</span>],<span class="string">'e'</span></span><br><span class="line">	mov <span class="keyword">byte</span> [<span class="number">0x16</span>],<span class="string">' '</span></span><br><span class="line">	mov <span class="keyword">byte</span> [<span class="number">0x18</span>],<span class="string">'O'</span></span><br><span class="line">	mov <span class="keyword">byte</span> [<span class="number">0x1a</span>],<span class="string">'K'</span></span><br><span class="line"></span><br><span class="line">	mov cx,<span class="number">00000000000</span>_11_000B</span><br><span class="line">	mov ss,cx</span><br><span class="line">	mov esp,<span class="number">0x7c00</span></span><br><span class="line">	mov ebp,esp</span><br><span class="line">	push <span class="keyword">byte</span> <span class="string">'.'</span></span><br><span class="line">	sub ebp,<span class="number">4</span></span><br><span class="line">	cmp ebp,esp</span><br><span class="line">	jnz ghalt</span><br><span class="line">	pop eax</span><br><span class="line">	mov [<span class="number">0x1c</span>],al</span><br><span class="line"> ghalt:</span><br><span class="line">	hlt</span><br><span class="line"></span><br><span class="line">	gdt_size: dw <span class="number">0</span></span><br><span class="line">	gdt_base: dd <span class="number">0x00007e00</span></span><br><span class="line"></span><br><span class="line">	times <span class="number">510</span>-($-$$) db <span class="number">0</span></span><br><span class="line">	db <span class="number">0x55</span>,<span class="number">0xaa</span></span><br></pre></td></tr></table></figure>



<h3 id="Macro"><a href="#Macro" class="headerlink" title="Macro*"></a>Macro*</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1: define a Macro</span><br><span class="line"></span><br><span class="line">%macro Descriptor 3   ; 3 is 3 parameter number</span><br><span class="line"><span class="code">	dw     %2 &amp; 0ffffh</span></span><br><span class="line"><span class="code">	dw     %1 &amp; 0ffffh</span></span><br><span class="line"><span class="code">	db     (%1 &gt;&gt; 16) &amp; 0ffh</span></span><br><span class="line"><span class="code">	dw     ((%2 &gt;&gt; 8) &amp; 0f00h) | (%3 &amp; 0f0ffh)</span></span><br><span class="line"><span class="code">	db     (%1 &gt;&gt; 24) &amp; 0ffh</span></span><br><span class="line">%endmacro</span><br><span class="line"></span><br><span class="line">2: use it in asm file</span><br><span class="line"></span><br><span class="line">LABEL_GDT:   Descriptor   0,     0     ,0</span><br><span class="line"></span><br><span class="line">Preprocessor will receive 3 parameters into macro definition and then substitute Descriptor for the macro code, which is there dw, dw, db, dw, db.</span><br></pre></td></tr></table></figure>



<h3 id="CPL-DPL-RPL"><a href="#CPL-DPL-RPL" class="headerlink" title="CPL, DPL, RPL*"></a>CPL, DPL, RPL*</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">CPL: Current Privilege Level saved in cs or ss. It may be equal to current segment descriptor privilege but may not. If one app shifts to another lower privilege app, CPL will change.</span><br><span class="line"></span><br><span class="line">DPL: Descriptor Privilege Level saved in segment descriptor</span><br><span class="line"></span><br><span class="line">RPL: Request Privilege Level saved in selector.</span><br></pre></td></tr></table></figure>



<h3 id="Gate"><a href="#Gate" class="headerlink" title="Gate*"></a>Gate*</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Calling a gate has two parts:from lower privilege to higher with call</span><br><span class="line"><span class="code">							:from higher privilege to lower with ret</span></span><br></pre></td></tr></table></figure>



<h3 id="CR-0-4"><a href="#CR-0-4" class="headerlink" title="CR 0-4*"></a>CR 0-4*</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">CR0: include flags to control CPU mode and system control</span><br><span class="line">CR1: kept</span><br><span class="line">CR2: include liner address leading to page fault</span><br><span class="line">CR3: Page Directory Base address Register</span><br><span class="line"></span><br><span class="line">CR3 just has 20 bits page directory base address, which means page directory table will be 4-KB alignment as PDE and PTE be.</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Assembly language</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>mbr</tag>
      </tags>
  </entry>
  <entry>
    <title>computer organization noun excerpts</title>
    <url>/2021/04/21/computer%20organization%20noun%20excerpts/</url>
    <content><![CDATA[<p><img src="/2021/04/21/computer%20organization%20noun%20excerpts/0.jpg" alt="0"></p>
<a id="more"></a>

<p>服务器(server)：用于为多用户运行大型程序的计算机，通常由多个用户并行使用，并且一般通过网络访问。</p>
<p>云计算(Cloud Computing)：在网络上提供服务的大服务器集群，它依赖于称为仓储规模计算机(Warehouse Scale Computer ,WSC)的巨型数据中心。一些运营商根据应用需求出租不同的服务器。</p>
<p>软件即服务(Software as a Service,SaaS)：在网络上以服务的方式提供软件和数据。其运行方式通常不是在本地设备上运行所有的二进制代码，而是通过诸如运行在本地客户端的浏览器的小程序登录到远程服务器上执行。典型的例子是Web搜索和社交网络。</p>
<p>程序性能影响因素：程序所用算法的有效性，用来建立程序并将其翻译成机器指令的软件系统，计算机执行机器指令的有效性。</p>
<p><strong>计算机系统结构中的8个伟大思想</strong>：面向摩尔定律的设计（Moore’ Law）；使用抽象简化设计；加速大概率事件（common case fast）；通过并行提高性能；通过流水线提高性能（pipelining）；通过预测提高性能（prediction）；存储器层次（hierarchy of memory）；通过冗余提高可靠性。</p>
<p>编译程序(Compiler)：将高级语言翻译为计算机所能识别的机器语言的程序。</p>
<p>指令(Instruction)：计算机硬件所能理解并服从的命令。</p>
<p><strong>重点1</strong>：组成计算机的5个经典部件是输入，输出，存储器，数据通路(datapath)（在计算机也称为运算器）和控制器，其中最后两个部件通常合称为处理器。你总能够把任何计算机（无论是现在的还是过去的）中的任何部件归于这五种之一。</p>
<p>集成电路（Integrated Circuit）：也叫芯片（chip），一种将几十个至几百万格晶体管连接起来的设备。</p>
<p>指令集体系结构（instruction set architecture）：也叫体系结构，是低层次软件和硬件之间的抽象接口，包含了需要编写正确运行的机器语言程序所需要的全部信息，包括指令，寄存器，存储访问和I/O等。</p>
<p>应用二进制接口（Application Binary interface）：用户部分的指令加上应用程序员调用的操作系统接口，定义了二进制层次可移植的计算机的标准。</p>
<p><strong>重点2</strong>：无论是硬件还是软件都可以使用抽象分成多个层次，每个较低的层次把细节对上层隐藏起来。抽象层次中的一个关键接口是指令集体系结构–硬件和底层软件之间的接口。这一抽象接口使得同一软件可以由成本不同，性能也不同的实现方法来完成。</p>
<p>易失性存储器(volatile memory)：类似于DRAM的存储器，仅在加电时保存数据。</p>
<p>非易失性存储器(nonvolatile memory)：在断电时仍可保持数据的存储器。如DVD。</p>
<p>晶体管（transistor）：是一种收电流控制的开关。</p>
<p>响应时间（response time）：也叫执行时间（execution time），是计算机完成某任务所需的总时间，包括硬盘访问，内存访问，I/O活动，操作系统开销和CPU执行时间等。</p>
<p>吞吐率（throughput）：也叫带宽（bandwidth），性能的另一种度量参数，表示单位时间内完成的任务数量。</p>
]]></content>
      <categories>
        <category>computer hardware</category>
      </categories>
  </entry>
  <entry>
    <title>infix expression into prefix expression</title>
    <url>/2021/04/21/infix%20expression%20into%20prefix%20expression/</url>
    <content><![CDATA[<p><img src="/2021/04/21/infix%20expression%20into%20prefix%20expression/0.jpg" alt="0"></p>
<a id="more"></a>

<p>基本思想：从左到右扫描，遇到数字直接输出，遇到+，-，*，/则进栈。入栈规则如下：</p>
<p>遇到一个操作符则与栈顶元素比较优先级，若大于栈顶操作符的优先级则将该操作符入栈，否则不断将操作符出栈直至该操作符优先级小于栈顶操作符（注意，同等优先级，左边的操作符优先级高）。举例如下：</p>
<p>将如下中缀表达式转化成后缀表达式：2+9/3-5</p>
<p>输出：2                                    栈：</p>
<p>输出：2                                    栈：+</p>
<p>输出：29                                  栈：+</p>
<p>输出：29                                  栈：+/</p>
<p>输出：293                                栈：+/</p>
<p>输出：293/+                            栈：-</p>
<p>输出：293/+5-</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>access cycle and access time</title>
    <url>/2021/04/21/access%20cycle%20and%20access%20time/</url>
    <content><![CDATA[<p><img src="/2021/04/21/access%20cycle%20and%20access%20time/0.jpg" alt="0"></p>
<a id="more"></a>

<p>存取时间：存取时间是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。</p>
<p>存取周期：存取周期又称为读写周期或访问周期。它是指存储器进行一次完整的读写操作所需的全部时间，即<strong>连续两次独立访问存储器操作之间所需的最小时间间隔。</strong></p>
<p>上面两个概念乍一看基本相同，其实不一样。关键在于存取周期=存取时间+恢复时间。</p>
<p>那么What is recover time？</p>
<p>对任何一种存储器，在读写操作之后，总要有一段恢复内部状态的复原时间。对于破坏性读出的存储器，存取周期往往比存取大得多（这意味着恢复时间较长）。故通常来说存取周期是大于存取时间的。（图在王道P94）</p>
]]></content>
      <categories>
        <category>computer hardware</category>
      </categories>
  </entry>
</search>
